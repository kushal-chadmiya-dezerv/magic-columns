"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@hookstate";
exports.ids = ["vendor-chunks/@hookstate"];
exports.modules = {

/***/ "(ssr)/./node_modules/@hookstate/core/dist/index.es.js":
/*!*******************************************************!*\
  !*** ./node_modules/@hookstate/core/dist/index.es.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StateFragment: () => (/* binding */ StateFragment),\n/* harmony export */   __state: () => (/* binding */ __state),\n/* harmony export */   configure: () => (/* binding */ configure),\n/* harmony export */   destroy: () => (/* binding */ destroy),\n/* harmony export */   extend: () => (/* binding */ extend),\n/* harmony export */   hookstate: () => (/* binding */ hookstate),\n/* harmony export */   hookstateMemo: () => (/* binding */ hookstateMemo),\n/* harmony export */   isHookstate: () => (/* binding */ isHookstate),\n/* harmony export */   isHookstateValue: () => (/* binding */ isHookstateValue),\n/* harmony export */   none: () => (/* binding */ none),\n/* harmony export */   suspend: () => (/* binding */ suspend),\n/* harmony export */   useHookstate: () => (/* binding */ useHookstate),\n/* harmony export */   useHookstateCallback: () => (/* binding */ useHookstateCallback),\n/* harmony export */   useHookstateEffect: () => (/* binding */ useHookstateEffect),\n/* harmony export */   useHookstateImperativeHandle: () => (/* binding */ useHookstateImperativeHandle),\n/* harmony export */   useHookstateInsertionEffect: () => (/* binding */ useHookstateInsertionEffect),\n/* harmony export */   useHookstateLayoutEffect: () => (/* binding */ useHookstateLayoutEffect),\n/* harmony export */   useHookstateMemo: () => (/* binding */ useHookstateMemo)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise */ var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n/**\n * Copied from fbjs is-shallow-equal\n */ var hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */ function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n        // Steps 6.b-6.e: +0 != -0\n        // Added the nonzero y check to make Flow happy, but it is redundant\n        return x !== 0 || y !== 0 || 1 / x === 1 / y;\n    } else {\n        // Step 6.a: NaN == NaN\n        return x !== x && y !== y;\n    }\n}\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */ function shallowEqual(objA, objB) {\n    if (is(objA, objB)) {\n        return true;\n    }\n    if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n        return false;\n    }\n    var keysA = Object.keys(objA);\n    var keysB = Object.keys(objB);\n    if (keysA.length !== keysB.length) {\n        return false;\n    }\n    // Test for A's keys different from B.\n    for(var i = 0; i < keysA.length; i++){\n        if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Special symbol which might be used to delete properties\n * from an object calling [State.set](#set) or [State.merge](#merge).\n *\n * [Learn more...](https://hookstate.js.org/docs/nested-state#deleting-existing-element)\n */ var none = Symbol(\"none\");\n// type PickByType<T, U, B = false> = Pick<T, KeysOfType<T, U, B>>;\n/**\n * A symbol which is used for type inference marking.\n *\n * @hidden\n * @ignore\n */ var __state = Symbol(\"__state\");\nfunction hookstate(initial, extension) {\n    var store = createStore(initial);\n    store.activate(extension);\n    var methods = store.toMethods();\n    return methods.self();\n}\n/**\n * A method to destroy a global state and resources allocated by the extensions\n */ function destroy(state) {\n    state[self].deactivate();\n}\n/**\n * A method to check if a variable is an instance of Hookstate State\n */ function isHookstate(v) {\n    return !!(v === null || v === void 0 ? void 0 : v[self]);\n}\n/**\n * A method to check if a variable is an instance of traced (wrapped in a proxy) Hookstate Value\n */ function isHookstateValue(v) {\n    return !!(v === null || v === void 0 ? void 0 : v[SelfMethodsID]);\n}\n/**\n * A function combines multiple extensions into one extension and returns it\n * Browse an example [here](https://hookstate.js.org/docs/extensions-snapshotable)\n */ function extend(e1, e2, e3, e4, e5) {\n    function extended(extensions) {\n        var exts = extensions.map(function(i) {\n            return i();\n        });\n        var onInitCbs = exts.map(function(i) {\n            return i.onInit;\n        }).filter(function(i) {\n            return i;\n        });\n        var onPremergeCbs = exts.map(function(i) {\n            return i.onPremerge;\n        }).filter(function(i) {\n            return i;\n        });\n        var onPresetCbs = exts.map(function(i) {\n            return i.onPreset;\n        }).filter(function(i) {\n            return i;\n        });\n        var onSetCbs = exts.map(function(i) {\n            return i.onSet;\n        }).filter(function(i) {\n            return i;\n        });\n        var onDestroyCbs = exts.map(function(i) {\n            return i.onDestroy;\n        }).filter(function(i) {\n            return i;\n        });\n        var result = {\n            onCreate: function(instanceFactory, combinedMethods) {\n                for(var _i = 0, exts_1 = exts; _i < exts_1.length; _i++){\n                    var ext = exts_1[_i];\n                    if (ext.onCreate) {\n                        var extMethods = ext.onCreate(instanceFactory, combinedMethods);\n                        Object.assign(combinedMethods, extMethods);\n                    }\n                }\n                return combinedMethods;\n            }\n        };\n        if (onInitCbs.length > 0) {\n            result.onInit = function(s, e) {\n                for(var _i = 0, onInitCbs_1 = onInitCbs; _i < onInitCbs_1.length; _i++){\n                    var cb = onInitCbs_1[_i];\n                    cb(s, e);\n                }\n            };\n        }\n        if (onPremergeCbs.length > 0) {\n            result.onPremerge = function(s, d, r) {\n                for(var _i = 0, onPremergeCbs_1 = onPremergeCbs; _i < onPremergeCbs_1.length; _i++){\n                    var cb = onPremergeCbs_1[_i];\n                    cb(s, d, r);\n                }\n            };\n        }\n        if (onPresetCbs.length > 0) {\n            result.onPreset = function(s, d, r) {\n                for(var _i = 0, onPresetCbs_1 = onPresetCbs; _i < onPresetCbs_1.length; _i++){\n                    var cb = onPresetCbs_1[_i];\n                    cb(s, d, r);\n                }\n            };\n        }\n        if (onSetCbs.length > 0) {\n            result.onSet = function(s, d, r) {\n                for(var _i = 0, onSetCbs_1 = onSetCbs; _i < onSetCbs_1.length; _i++){\n                    var cb = onSetCbs_1[_i];\n                    cb(s, d, r);\n                }\n            };\n        }\n        if (onDestroyCbs.length > 0) {\n            result.onDestroy = function(s) {\n                for(var _i = 0, onDestroyCbs_1 = onDestroyCbs; _i < onDestroyCbs_1.length; _i++){\n                    var cb = onDestroyCbs_1[_i];\n                    cb(s);\n                }\n            };\n        }\n        return result;\n    }\n    return function() {\n        return extended([\n            e1,\n            e2,\n            e3,\n            e4,\n            e5\n        ].filter(function(i) {\n            return i;\n        }));\n    };\n}\nfunction useHookstate(source, extension) {\n    var parentMethods = Object(source) === source ? source[self] : undefined;\n    if (parentMethods) {\n        if (parentMethods.isMounted) {\n            // Scoped state mount\n            // eslint-disable-next-line react-hooks/rules-of-hooks\n            var initializer = function() {\n                // warning: this is called twice in react strict mode\n                var store = parentMethods.store;\n                var onSetUsedCallback = function() {\n                    return setValue_1({\n                        store: store,\n                        state: state,\n                        source: value_1.source,\n                        parentMethods: parentMethods\n                    });\n                };\n                var state = new StateMethodsImpl(store, parentMethods.path, store.get(parentMethods.path), store.edition, onSetUsedCallback);\n                return {\n                    store: store,\n                    state: state,\n                    source: source,\n                    parentMethods: parentMethods\n                };\n            };\n            var _a = react__WEBPACK_IMPORTED_MODULE_0___default().useState(initializer), value_1 = _a[0], setValue_1 = _a[1];\n            if (value_1.store !== parentMethods.store || !(\"source\" in value_1)) {\n                value_1.state.onUnmount();\n                value_1.parentMethods.unsubscribe(value_1.state);\n                value_1 = initializer();\n            }\n            // TODO move to a class hide props on prototype level\n            // hide props from development tools\n            Object.defineProperty(value_1, \"store\", {\n                enumerable: false\n            });\n            Object.defineProperty(value_1, \"state\", {\n                enumerable: false\n            });\n            Object.defineProperty(value_1, \"source\", {\n                enumerable: false\n            });\n            Object.defineProperty(value_1, \"parentMethods\", {\n                enumerable: false\n            });\n            value_1.state.reconstruct(parentMethods.path, value_1.store.get(parentMethods.path), value_1.store.edition, // parent state object has changed its reference object\n            // so the scopped state should change too\n            value_1.source !== source);\n            value_1.source = source;\n            // need to subscribe in sync mode, because\n            // safari delays calling the effect giving priority to timeouts and network events,\n            // which can cause the state update\n            parentMethods.subscribe(value_1.state); // no-op if already subscribed\n            useIsomorphicLayoutEffect(function() {\n                // warning: in strict mode, effect is called twice\n                // so need to restore subscription and reconstruct the extension\n                // after the first effect unmount callback\n                value_1.state.onMount(); // no-op if already mounted\n                parentMethods.subscribe(value_1.state); // no-op if already subscribed\n                return function() {\n                    value_1.state.onUnmount();\n                    parentMethods.unsubscribe(value_1.state);\n                };\n            }, []);\n            var state = value_1.state.self();\n            // expose property in development tools\n            value_1[\"[hookstate(scoped)]\"] = state; // TODO use label here, add core extension to label states\n            return state;\n        } else {\n            // Global state mount or destroyed link\n            // eslint-disable-next-line react-hooks/rules-of-hooks\n            var initializer = function() {\n                // warning: this is called twice in react strict mode\n                var store = parentMethods.store;\n                var onSetUsedCallback = function() {\n                    return value_2.state.isMounted && setValue_2({\n                        store: store,\n                        state: state,\n                        source: value_2.source // mutable, get the latest from value\n                    });\n                };\n                var state = new StateMethodsImpl(store, RootPath, store.get(RootPath), store.edition, onSetUsedCallback);\n                return {\n                    store: store,\n                    state: state,\n                    source: source\n                };\n            };\n            var _b = react__WEBPACK_IMPORTED_MODULE_0___default().useState(initializer), value_2 = _b[0], setValue_2 = _b[1];\n            if (value_2.store !== parentMethods.store || !(\"source\" in value_2)) {\n                value_2.state.onUnmount();\n                value_2.store.unsubscribe(value_2.state);\n                value_2 = initializer();\n            }\n            // hide props from development tools\n            Object.defineProperty(value_2, \"store\", {\n                enumerable: false\n            });\n            Object.defineProperty(value_2, \"state\", {\n                enumerable: false\n            });\n            Object.defineProperty(value_2, \"source\", {\n                enumerable: false\n            });\n            value_2.state.reconstruct(RootPath, value_2.store.get(RootPath), value_2.store.edition, // parent state object has changed its reference object\n            // so the scopped state should change too\n            value_2.source !== source);\n            value_2.source = source;\n            // need to subscribe in sync mode, because\n            // safari delays calling the effect giving priority to timeouts and network events,\n            // which can cause the state update\n            value_2.store.subscribe(value_2.state); // no-op if already subscribed\n            useIsomorphicLayoutEffect(function() {\n                // warning: in strict mode, effect is called twice\n                // so need to restore subscription and reconstruct the extension\n                // after the first effect unmount callback\n                value_2.state.onMount(); // no-op if already mounted\n                value_2.store.subscribe(value_2.state); // no-op if already subscribed\n                return function() {\n                    value_2.state.onUnmount();\n                    value_2.store.unsubscribe(value_2.state);\n                };\n            }, []);\n            var state = value_2.state.self();\n            for(var ind = 0; ind < parentMethods.path.length; ind += 1){\n                state = state.nested(parentMethods.path[ind]);\n            }\n            // expose property in development tools\n            value_2[\"[hookstate(global)]\"] = state; // TODO use label here, add core extension to label states\n            return state;\n        }\n    } else {\n        // Local state mount\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        var initializer = function() {\n            // warning: this is called twice in react strict mode\n            var store = createStore(source);\n            var onSetUsedCallback = function() {\n                return value_3.state.isMounted && setValue_3({\n                    store: store,\n                    state: state\n                });\n            };\n            var state = new StateMethodsImpl(store, RootPath, store.get(RootPath), store.edition, onSetUsedCallback);\n            return {\n                store: store,\n                state: state\n            };\n        };\n        var _c = react__WEBPACK_IMPORTED_MODULE_0___default().useState(initializer), value_3 = _c[0], setValue_3 = _c[1];\n        if (\"source\" in value_3) {\n            value_3.state.onUnmount();\n            value_3.store.unsubscribe(value_3.state);\n            value_3.store.deactivate();\n            value_3 = initializer();\n        }\n        // hide props from development tools\n        Object.defineProperty(value_3, \"store\", {\n            enumerable: false\n        });\n        Object.defineProperty(value_3, \"state\", {\n            enumerable: false\n        });\n        value_3.state.reconstruct(RootPath, value_3.store.get(RootPath), value_3.store.edition, false);\n        // need to subscribe in sync mode, because\n        // safari delays calling the effect giving priority to timeouts and network events,\n        // which can cause the state update\n        value_3.store.subscribe(value_3.state); // no-op if already subscribed\n        // need to attach the extension straight away\n        // because extension methods are used in render function\n        // and we can not defer it to the effect callback\n        value_3.store.activate(extension); // no-op if already attached\n        useIsomorphicLayoutEffect(function() {\n            // warning: in strict mode, effect is called twice\n            // so need to restore subscription and reconstruct the extension\n            // after the first effect unmount callback\n            value_3.state.onMount(); // no-op if already mounted\n            value_3.store.subscribe(value_3.state); // no-op if already subscribed\n            value_3.store.activate(extension); // no-op if already attached\n            return function() {\n                value_3.state.onUnmount();\n                value_3.store.unsubscribe(value_3.state);\n                value_3.store.deactivate(); // this will destroy the extensions\n            };\n        }, []);\n        var state = value_3.state.self();\n        // expose property in development tools\n        value_3[\"[hookstate(local)]\"] = state; // TODO use label here, add core extension to label states\n        return state;\n    }\n}\nfunction StateFragment(props) {\n    var scoped = useHookstate(props.state, props.extension);\n    return props.suspend && suspend(scoped) || props.children(scoped);\n}\n/**\n * If state is promised, then it returns a component which integrates with React 18 Suspend feature automatically.\n * Note, that React 18 Suspend support for data loading is still experimental,\n * but it worked as per our experiments and testing.\n */ function suspend(state) {\n    var p = state.promise;\n    return p && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().lazy(function() {\n        return p;\n    }));\n}\n///\n/// INTERNAL SYMBOLS (LIBRARY IMPLEMENTATION)\n///\nvar self = Symbol(\"self\");\nvar ErrorId;\n(function(ErrorId) {\n    ErrorId[ErrorId[\"StateUsedInDependencyList\"] = 100] = \"StateUsedInDependencyList\";\n    ErrorId[ErrorId[\"InitStateToValueFromState\"] = 101] = \"InitStateToValueFromState\";\n    ErrorId[ErrorId[\"SetStateToValueFromState\"] = 102] = \"SetStateToValueFromState\";\n    ErrorId[ErrorId[\"GetStateWhenPromised\"] = 103] = \"GetStateWhenPromised\";\n    ErrorId[ErrorId[\"SetStateWhenPromised\"] = 104] = \"SetStateWhenPromised\";\n    ErrorId[ErrorId[\"SetStateNestedToPromised\"] = 105] = \"SetStateNestedToPromised\";\n    ErrorId[ErrorId[\"SetStateWhenDestroyed\"] = 106] = \"SetStateWhenDestroyed\";\n    ErrorId[ErrorId[\"ToJson_Value\"] = 108] = \"ToJson_Value\";\n    ErrorId[ErrorId[\"ToJson_State\"] = 109] = \"ToJson_State\";\n    ErrorId[ErrorId[\"GetProperty_Function\"] = 110] = \"GetProperty_Function\";\n    ErrorId[ErrorId[\"InitStateStoreSwitchover\"] = 111] = \"InitStateStoreSwitchover\";\n    ErrorId[ErrorId[\"GetUnknownPlugin\"] = 120] = \"GetUnknownPlugin\";\n    ErrorId[ErrorId[\"SetProperty_State\"] = 201] = \"SetProperty_State\";\n    ErrorId[ErrorId[\"SetProperty_Value\"] = 202] = \"SetProperty_Value\";\n    ErrorId[ErrorId[\"SetPrototypeOf_State\"] = 203] = \"SetPrototypeOf_State\";\n    ErrorId[ErrorId[\"SetPrototypeOf_Value\"] = 204] = \"SetPrototypeOf_Value\";\n    ErrorId[ErrorId[\"PreventExtensions_State\"] = 205] = \"PreventExtensions_State\";\n    ErrorId[ErrorId[\"PreventExtensions_Value\"] = 206] = \"PreventExtensions_Value\";\n    ErrorId[ErrorId[\"DefineProperty_State\"] = 207] = \"DefineProperty_State\";\n    ErrorId[ErrorId[\"DefineProperty_Value\"] = 208] = \"DefineProperty_Value\";\n    ErrorId[ErrorId[\"DeleteProperty_State\"] = 209] = \"DeleteProperty_State\";\n    ErrorId[ErrorId[\"DeleteProperty_Value\"] = 210] = \"DeleteProperty_Value\";\n    ErrorId[ErrorId[\"Construct_State\"] = 211] = \"Construct_State\";\n    ErrorId[ErrorId[\"Construct_Value\"] = 212] = \"Construct_Value\";\n    ErrorId[ErrorId[\"Apply_State\"] = 213] = \"Apply_State\";\n    ErrorId[ErrorId[\"Apply_Value\"] = 214] = \"Apply_Value\";\n})(ErrorId || (ErrorId = {}));\nvar StateInvalidUsageError = /** @class */ function(_super) {\n    __extends(StateInvalidUsageError, _super);\n    function StateInvalidUsageError(path, id, details) {\n        return _super.call(this, \"Error: HOOKSTATE-\".concat(id, \" [path: /\").concat(path.join(\"/\")).concat(details ? \", details: \".concat(details) : \"\", \"]. \") + \"See https://hookstate.js.org/docs/exceptions#hookstate-\".concat(id)) || this;\n    }\n    return StateInvalidUsageError;\n}(Error);\nvar SelfMethodsID = Symbol(\"ProxyMarker\");\nvar RootPath = [];\nvar Store = /** @class */ function() {\n    function Store(_value) {\n        var _this = this;\n        this._value = _value;\n        // > 0 means active store, < 0 means destroyed\n        // please note, in react strict mode and hot reload cases\n        // state can be reused, so we should support store resurection\n        this.edition = 1;\n        this._subscribers = new Set();\n        if (Object(_value) === _value && configuration.promiseDetector(_value)) {\n            this.setPromised(_value);\n        } else if (_value === none) {\n            this.setPromised(undefined);\n        }\n        var onSetUsedStoreStateMethods = function() {\n            _this._stateMethods.reconstruct(RootPath, _this.get(RootPath), _this.edition, false);\n        };\n        onSetUsedStoreStateMethods[IsUnmounted] = true;\n        this._stateMethods = new StateMethodsImpl(this, RootPath, this.get(RootPath), this.edition, onSetUsedStoreStateMethods);\n        this.subscribe(this._stateMethods);\n    }\n    Store.prototype.setPromised = function(promise) {\n        var _this = this;\n        this._value = none;\n        this._promiseError = undefined;\n        this._promiseResolver = undefined;\n        if (!promise) {\n            this._promise = new Promise(function(resolve) {\n                _this._promiseResolver = resolve;\n            });\n            return;\n        }\n        promise = promise.then(function(r) {\n            if (_this._promise === promise) {\n                _this._promise = undefined;\n                _this._promiseError = undefined;\n                _this._promiseResolver === undefined;\n                _this.update(_this._stateMethods.self(), _this.set(RootPath, r));\n            }\n        }).catch(function(err) {\n            if (_this._promise === promise) {\n                _this._promise = undefined;\n                _this._promiseResolver = undefined;\n                _this._promiseError = err;\n                _this.edition += 1;\n                var ad = {\n                    path: RootPath\n                };\n                _this.update(_this._stateMethods.self(), ad);\n            }\n        });\n        this._promise = promise;\n    };\n    Store.prototype.activate = function(extensionFactory) {\n        var _a, _b, _c, _d;\n        if (this.edition < 0) {\n            this.edition = -this.edition;\n        }\n        if (this._extension === undefined) {\n            this._extension = extensionFactory === null || extensionFactory === void 0 ? void 0 : extensionFactory();\n            this._extensionMethods = (_b = (_a = this._extension) === null || _a === void 0 ? void 0 : _a.onCreate) === null || _b === void 0 ? void 0 : _b.call(_a, this._stateMethods.self(), {});\n            // this is invoked with all extension methods activated on the state\n            (_d = (_c = this._extension) === null || _c === void 0 ? void 0 : _c.onInit) === null || _d === void 0 ? void 0 : _d.call(_c, this._stateMethods.self(), this._extensionMethods || {});\n        }\n    };\n    Store.prototype.deactivate = function() {\n        var _a, _b;\n        if (this._extension) {\n            (_b = (_a = this._extension).onDestroy) === null || _b === void 0 ? void 0 : _b.call(_a, this._stateMethods.self());\n            delete this._extension;\n            delete this._extensionMethods;\n        }\n        if (this.edition > 0) {\n            this.edition = -this.edition;\n        }\n    };\n    Object.defineProperty(Store.prototype, \"extension\", {\n        get: function() {\n            return this._extensionMethods;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Store.prototype, \"promise\", {\n        get: function() {\n            return this._promise;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Store.prototype, \"promiseError\", {\n        get: function() {\n            return this._promiseError;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Store.prototype.get = function(path) {\n        var result = this._value;\n        if (result === none) {\n            return result;\n        }\n        path.forEach(function(p) {\n            result = result[p];\n        });\n        return result;\n    };\n    Store.prototype.set = function(path, value) {\n        var _a, _b;\n        if (path.length === 0) {\n            // Root value UPDATE case,\n            if (value === none) {\n                this.setPromised(undefined);\n            } else if (Object(value) === value && configuration.promiseDetector(value)) {\n                this.setPromised(value);\n                value = none;\n            } else if (this._promise && !this._promiseResolver) {\n                throw new StateInvalidUsageError(path, ErrorId.SetStateWhenPromised);\n            } else {\n                this._promiseError = undefined;\n            }\n            var prevValue = this._value;\n            this._value = value;\n            this.afterSet();\n            if (prevValue === none && this._value !== none && this._promiseResolver) {\n                this._promise = undefined;\n                this._promiseError = undefined;\n                var resolver = this._promiseResolver;\n                this._promiseResolver === undefined;\n                resolver(this._value);\n            }\n            return {\n                path: path\n            };\n        }\n        if (Object(value) === value && configuration.promiseDetector(value)) {\n            // TODO this one still can get into the state as nested property, need to check on read instead\n            throw new StateInvalidUsageError(path, ErrorId.SetStateNestedToPromised);\n        }\n        var target = this._value;\n        for(var i = 0; i < path.length - 1; i += 1){\n            target = target[path[i]];\n        }\n        var p = path[path.length - 1];\n        if (p in target) {\n            if (value !== none) {\n                // Property UPDATE case\n                target[p] = value;\n                this.afterSet();\n                return {\n                    path: path\n                };\n            } else {\n                // Property DELETE case\n                if (Array.isArray(target) && typeof p === \"number\") {\n                    target.splice(p, 1);\n                } else {\n                    delete target[p];\n                }\n                this.afterSet();\n                // if an array of objects is about to loose existing property\n                // we consider it is the whole object is changed\n                // which is identified by upper path\n                return {\n                    path: path.slice(0, -1),\n                    actions: (_a = {}, _a[p] = \"D\", _a)\n                };\n            }\n        }\n        if (value !== none) {\n            // Property INSERT case\n            target[p] = value;\n            this.afterSet();\n            // if an array of objects is about to be extended by new property\n            // we consider it is the whole object is changed\n            // which is identified by upper path\n            return {\n                path: path.slice(0, -1),\n                actions: (_b = {}, _b[p] = \"I\", _b)\n            };\n        }\n        // Non-existing property DELETE case\n        // no-op\n        return {\n            path: path\n        };\n    };\n    Store.prototype.preset = function(state, value) {\n        var _a, _b;\n        (_b = (_a = this._extension) === null || _a === void 0 ? void 0 : _a.onPreset) === null || _b === void 0 ? void 0 : _b.call(_a, state, value, this._stateMethods.self());\n    };\n    Store.prototype.premerge = function(state, value) {\n        var _a, _b;\n        (_b = (_a = this._extension) === null || _a === void 0 ? void 0 : _a.onPremerge) === null || _b === void 0 ? void 0 : _b.call(_a, state, value, this._stateMethods.self());\n    };\n    Store.prototype.update = function(state, ad) {\n        var _this = this;\n        var _a, _b;\n        (_b = (_a = this._extension) === null || _a === void 0 ? void 0 : _a.onSet) === null || _b === void 0 ? void 0 : _b.call(_a, state, ad, this._stateMethods.self());\n        var actions = new Set();\n        // check if actions descriptor can be unfolded into a number of individual update actions\n        // this is the case when merge call swaps to properties for example\n        // so we optimize rerendering only these properties\n        if (ad.actions && Object.values(ad.actions).findIndex(function(i) {\n            return i !== \"U\";\n        }) === -1) {\n            // all actions are update actions\n            Object.keys(ad.actions).forEach(function(key) {\n                _this._subscribers.forEach(function(s) {\n                    return s.onSet({\n                        path: ad.path.concat(key)\n                    }, actions);\n                });\n            });\n        } else {\n            this._subscribers.forEach(function(s) {\n                return s.onSet(ad, actions);\n            });\n        }\n        actions.forEach(function(a) {\n            return a();\n        });\n    };\n    Store.prototype.afterSet = function() {\n        if (this.edition > 0) {\n            this.edition += 1;\n        }\n        if (this.edition < 0) {\n            this.edition -= 1;\n        }\n    };\n    Store.prototype.toMethods = function() {\n        return this._stateMethods;\n    };\n    Store.prototype.subscribe = function(l) {\n        this._subscribers.add(l);\n    };\n    Store.prototype.unsubscribe = function(l) {\n        this._subscribers.delete(l);\n    };\n    Store.prototype.toJSON = function() {\n        throw new StateInvalidUsageError(RootPath, ErrorId.ToJson_Value);\n    };\n    return Store;\n}();\n// use symbol property to allow for easier reference finding\nvar UnusedValue = Symbol(\"UnusedValue\");\n// use symbol to mark that a function has no effect anymore\nvar IsUnmounted = Symbol(\"IsUnmounted\");\nvar StateMethodsImpl = /** @class */ function() {\n    function StateMethodsImpl(store, path, valueSource, valueEdition, onSetUsed) {\n        this.store = store;\n        this.path = path;\n        this.valueSource = valueSource;\n        this.valueEdition = valueEdition;\n        this.onSetUsed = onSetUsed;\n        this.valueUsed = UnusedValue;\n    }\n    Object.defineProperty(StateMethodsImpl.prototype, __state, {\n        get: function() {\n            return [\n                this.get(),\n                this.self()\n            ];\n        },\n        enumerable: false,\n        configurable: true\n    });\n    StateMethodsImpl.prototype.reconstruct = function(path, valueSource, valueEdition, reset) {\n        this.path = path;\n        this.valueSource = valueSource;\n        this.valueEdition = valueEdition;\n        this.valueUsed = UnusedValue;\n        if (reset) {\n            delete this.selfUsed;\n            delete this.childrenCreated;\n            delete this.childrenUsedPrevious;\n        } else {\n            this.valueUsedNoProxyPrevious = this.valueUsedNoProxy;\n            this.childrenUsedPrevious = this.childrenUsed;\n        }\n        delete this.valueUsedNoProxy;\n        delete this.childrenUsed;\n    // We should not delete subscribers as these are self cleaned up when unmounted\n    // Theoretically it is possible to reconnect subscribers like we done it for \n    // children, but it is easier and more efficient to leave subscribers to have independent lifecycle\n    // If we delete subscribers here, scoped states wrapped in React.memo\n    // will lose state change propagation and rerendering for scopped states\n    // delete this.subscribers;\n    };\n    StateMethodsImpl.prototype.reconnect = function() {\n        // Mark it's as used, because it is used in a dependency list\n        // (we are making it's value used implicitly, so rerender is triggered).\n        // Otherwise, no rerender => no effects running, even when a value is changed.\n        // This is marking the state used a bit more than it might be really used\n        // in the effect callback. More optimized / precise implementation would be\n        // to remember useSelf as previous (similar to childrenUsed),\n        // but it is a lot more complicated and the benefit is not worth the complexity.\n        // So, mark it used.\n        // We also using it without proxy if it wass used without proxy during the\n        // previous render, because otherwise children usage might be not traced completely\n        // and so will not result in renreder if children are updated.\n        // This is covered by some tests, but there are so many possible corner cases...\n        this.get({\n            __internalAllowPromised: true,\n            noproxy: this.valueUsedNoProxyPrevious\n        });\n        this.childrenUsed = __assign(__assign({}, this.childrenUsedPrevious), this.childrenUsed);\n    };\n    StateMethodsImpl.prototype.getUntracked = function(__internalAllowPromised) {\n        if (this.valueEdition !== this.store.edition) {\n            this.valueSource = this.store.get(this.path);\n            this.valueEdition = this.store.edition;\n            if (this.valueUsed !== UnusedValue) {\n                this.valueUsed = UnusedValue;\n                this.get({\n                    __internalAllowPromised: true\n                }); // renew cache to keep it marked used\n            }\n        }\n        if (__internalAllowPromised) {\n            return this.valueSource;\n        }\n        if (this.store.promiseError) {\n            throw this.store.promiseError;\n        }\n        if (this.store.promise) {\n            throw new StateInvalidUsageError(this.path, ErrorId.GetStateWhenPromised);\n        }\n        return this.valueSource;\n    };\n    StateMethodsImpl.prototype.get = function(options) {\n        var _a;\n        var valueSource = this.getUntracked(options === null || options === void 0 ? void 0 : options.__internalAllowPromised);\n        if (options === null || options === void 0 ? void 0 : options.stealth) {\n            return valueSource;\n        }\n        if (this.valueUsed === UnusedValue) {\n            if (Array.isArray(valueSource)) {\n                this.valueUsed = this.valueArrayImpl(valueSource);\n            } else if (Object(valueSource) === valueSource) {\n                if (((_a = valueSource.constructor) === null || _a === void 0 ? void 0 : _a.name) === \"Object\") {\n                    this.valueUsed = this.valueObjectImpl(valueSource);\n                } else {\n                    // any other object except Object, for example Date\n                    this.valueUsedNoProxy = true;\n                    this.valueUsed = valueSource;\n                }\n            } else {\n                this.valueUsed = valueSource;\n            }\n        }\n        if (options === null || options === void 0 ? void 0 : options.noproxy) {\n            this.valueUsedNoProxy = true;\n            return valueSource;\n        }\n        return this.valueUsed;\n    };\n    Object.defineProperty(StateMethodsImpl.prototype, \"value\", {\n        get: function() {\n            // various tools, including react dev tools and webpack import\n            // inspect an object and it's properties\n            // so these should not throw\n            // return this.get({ __internalAllowPromised: true })\n            return this.get();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    StateMethodsImpl.prototype.setUntrackedV4 = function(newValue) {\n        if (typeof newValue === \"function\") {\n            newValue = newValue(this.getUntracked());\n        }\n        this.store.preset(this.self(), newValue);\n        if (Object(newValue) === newValue && newValue[SelfMethodsID]) {\n            // TODO check on read instead as it might escape as nested on set anyway\n            throw new StateInvalidUsageError(this.path, ErrorId.SetStateToValueFromState);\n        }\n        if (newValue !== Object(newValue) && newValue === this.getUntracked(true)) {\n            // this is primitive value and has not changed\n            // so skip this set call as it does not make an effect\n            return null;\n        }\n        return this.store.set(this.path, newValue);\n    };\n    StateMethodsImpl.prototype.set = function(newValue) {\n        var ad = this.setUntrackedV4(newValue);\n        if (ad) {\n            this.store.update(this.self(), ad);\n        }\n    };\n    StateMethodsImpl.prototype.mergeUntracked = function(sourceValue) {\n        var r = this.mergeUntrackedV4(sourceValue);\n        if (r) {\n            return [\n                r.path\n            ];\n        }\n        return [];\n    };\n    StateMethodsImpl.prototype.mergeUntrackedV4 = function(sourceValue) {\n        var currentValue = this.getUntracked();\n        if (typeof sourceValue === \"function\") {\n            sourceValue = sourceValue(currentValue);\n        }\n        this.store.premerge(this.self(), sourceValue);\n        if (Array.isArray(currentValue)) {\n            if (Array.isArray(sourceValue)) {\n                var ad_1 = {\n                    path: this.path,\n                    actions: {}\n                };\n                sourceValue.forEach(function(e, i) {\n                    ad_1.actions[currentValue.push(e) - 1] = \"I\";\n                });\n                if (Object.keys(ad_1.actions).length > 0) {\n                    this.setUntrackedV4(currentValue);\n                    return ad_1;\n                }\n                return null;\n            } else {\n                var ad_2 = {\n                    path: this.path,\n                    actions: {}\n                };\n                var deletedIndexes_1 = [];\n                Object.keys(sourceValue).map(function(i) {\n                    return Number(i);\n                }).sort(function(a, b) {\n                    return a - b;\n                }).forEach(function(i) {\n                    var index = Number(i);\n                    var newPropValue = sourceValue[index];\n                    if (newPropValue === none) {\n                        ad_2.actions[index] = \"D\";\n                        deletedIndexes_1.push(index);\n                    } else {\n                        if (index in currentValue) {\n                            ad_2.actions[index] = \"U\";\n                        } else {\n                            ad_2.actions[index] = \"I\";\n                        }\n                        currentValue[index] = newPropValue;\n                    }\n                });\n                // indexes are ascending sorted as per above\n                // so, delete one by one from the end\n                // this way index positions do not change\n                deletedIndexes_1.reverse().forEach(function(p) {\n                    currentValue.splice(p, 1);\n                });\n                if (Object.keys(ad_2.actions).length > 0) {\n                    this.setUntrackedV4(currentValue);\n                    return ad_2;\n                }\n                return null;\n            }\n        } else if (Object(currentValue) === currentValue) {\n            var ad_3 = {\n                path: this.path,\n                actions: {}\n            };\n            Object.keys(sourceValue).forEach(function(key) {\n                var newPropValue = sourceValue[key];\n                if (newPropValue === none) {\n                    ad_3.actions[key] = \"D\";\n                    delete currentValue[key];\n                } else {\n                    if (key in currentValue) {\n                        ad_3.actions[key] = \"U\";\n                    } else {\n                        ad_3.actions[key] = \"I\";\n                    }\n                    currentValue[key] = newPropValue;\n                }\n            });\n            if (Object.keys(ad_3.actions).length > 0) {\n                this.setUntrackedV4(currentValue);\n                return ad_3;\n            }\n            return null;\n        } else if (typeof currentValue === \"string\") {\n            return this.setUntrackedV4(currentValue + String(sourceValue));\n        } else {\n            return this.setUntrackedV4(sourceValue);\n        }\n    };\n    StateMethodsImpl.prototype.merge = function(sourceValue) {\n        var r = this.mergeUntrackedV4(sourceValue);\n        if (r) {\n            this.store.update(this.self(), r);\n        }\n    };\n    StateMethodsImpl.prototype.nested = function(key) {\n        return this.child(key).self();\n    };\n    StateMethodsImpl.prototype.rerender = function(paths) {\n        for(var _i = 0, paths_1 = paths; _i < paths_1.length; _i++){\n            var path = paths_1[_i];\n            this.store.update(this.self(), {\n                path: path\n            });\n        }\n    };\n    StateMethodsImpl.prototype.activate = function(extensionFactory) {\n        this.store.activate(extensionFactory);\n    };\n    StateMethodsImpl.prototype.deactivate = function() {\n        this.store.deactivate();\n    };\n    StateMethodsImpl.prototype.subscribe = function(l) {\n        if (this.subscribers === undefined) {\n            this.subscribers = new Set();\n        }\n        this.subscribers.add(l);\n    };\n    StateMethodsImpl.prototype.unsubscribe = function(l) {\n        if (this.subscribers) {\n            this.subscribers.delete(l);\n        }\n    };\n    Object.defineProperty(StateMethodsImpl.prototype, \"isMounted\", {\n        get: function() {\n            return !this.onSetUsed[IsUnmounted];\n        },\n        enumerable: false,\n        configurable: true\n    });\n    StateMethodsImpl.prototype.onMount = function() {\n        delete this.onSetUsed[IsUnmounted];\n    };\n    StateMethodsImpl.prototype.onUnmount = function() {\n        this.onSetUsed[IsUnmounted] = true;\n    };\n    StateMethodsImpl.prototype.onSet = function(ad, actions) {\n        var _this = this;\n        var update = function() {\n            var _a;\n            var isAffected = false;\n            if (_this.valueUsedNoProxy && _this.valueUsed !== UnusedValue) {\n                actions.add(_this.onSetUsed);\n                delete _this.selfUsed;\n                isAffected = true;\n            }\n            var path = ad.path;\n            var nextChildKey = path[_this.path.length];\n            if (nextChildKey === undefined) {\n                // There is no next child to dive into\n                // So it is this one which was updated\n                if (_this.valueUsed !== UnusedValue) {\n                    actions.add(_this.onSetUsed);\n                    delete _this.selfUsed;\n                    delete _this.childrenUsed;\n                    if (ad.actions && _this.childrenCreated) {\n                        // TODO add automated unit tests for this part\n                        if (Array.isArray(_this.valueSource) && Object.values(ad.actions).includes(\"D\")) {\n                            // this is an array and some elements were removed\n                            // so invalidate cache for all children after the first deleted\n                            var firstDeletedIndex = Object.keys(ad.actions).map(function(i) {\n                                return Number(i);\n                            }).sort(function(a, b) {\n                                return a - b;\n                            }).find(function(i) {\n                                var _a;\n                                return ((_a = ad.actions) === null || _a === void 0 ? void 0 : _a[i]) === \"D\";\n                            });\n                            for(var childKey in _this.childrenCreated){\n                                if (Number(childKey) >= firstDeletedIndex || childKey in ad.actions) {\n                                    delete _this.childrenCreated[childKey];\n                                }\n                            }\n                        } else {\n                            for(var childKey in ad.actions){\n                                delete _this.childrenCreated[childKey];\n                            }\n                        }\n                    } else {\n                        delete _this.childrenCreated;\n                    }\n                    return true;\n                }\n            } else {\n                var nextChild = (_a = _this.childrenUsed) === null || _a === void 0 ? void 0 : _a[nextChildKey];\n                if (nextChild && nextChild.onSet(ad, actions)) {\n                    delete _this.selfUsed;\n                    return true;\n                }\n            }\n            return isAffected;\n        };\n        var updated = update();\n        if (!updated && this.subscribers !== undefined) {\n            this.subscribers.forEach(function(s) {\n                if (s.onSet(ad, actions)) {\n                    delete _this.selfUsed;\n                }\n            });\n        }\n        return updated;\n    };\n    Object.defineProperty(StateMethodsImpl.prototype, \"keys\", {\n        get: function() {\n            var value = this.get();\n            if (Array.isArray(value)) {\n                return Object.keys(value).map(function(i) {\n                    return Number(i);\n                }).filter(function(i) {\n                    return Number.isInteger(i);\n                });\n            }\n            if (Object(value) === value) {\n                return Object.keys(value);\n            }\n            return undefined;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    StateMethodsImpl.prototype.child = function(key) {\n        this.childrenUsed = this.childrenUsed || {};\n        var cachedChild = this.childrenUsed.hasOwnProperty(key) && this.childrenUsed[key];\n        if (cachedChild) {\n            return cachedChild;\n        }\n        var valueSource = this.valueSource[key];\n        if (typeof valueSource === \"function\") {\n            // hitting a method of a custom type, should be no-op\n            throw new StateInvalidUsageError(this.path, ErrorId.GetProperty_Function);\n        }\n        this.childrenCreated = this.childrenCreated || {};\n        var child = this.childrenCreated[key];\n        var r;\n        if (child) {\n            child.reconstruct(this.path.concat(key), valueSource, this.valueEdition, false);\n            r = child;\n        } else {\n            r = new StateMethodsImpl(this.store, this.path.concat(key), valueSource, this.valueEdition, this.onSetUsed);\n            this.childrenCreated[key] = r;\n        }\n        if (this.valueUsedNoProxy) {\n            // TODO this is redundant when Downgraded plugin is deleted\n            r.valueUsedNoProxy = true;\n        }\n        this.childrenUsed[key] = r;\n        return r;\n    };\n    StateMethodsImpl.prototype.valueArrayImpl = function(currentValue) {\n        var _this = this;\n        return proxyWrap(this.path, currentValue, function() {\n            return currentValue;\n        }, function(target, key) {\n            if (key === \"length\") {\n                return target.length;\n            }\n            if (key in Array.prototype) {\n                return Array.prototype[key];\n            }\n            if (key === SelfMethodsID) {\n                return _this;\n            }\n            if (typeof key === \"symbol\") {\n                // allow clients to associate hidden cache with state values\n                return target[key];\n            }\n            var index = Number(key);\n            if (!Number.isInteger(index)) {\n                return undefined;\n            }\n            return _this.child(index).get();\n        }, function(target, key, value) {\n            if (typeof key === \"symbol\") {\n                // allow clients to associate hidden cache with state values\n                target[key] = value;\n                return true;\n            }\n            throw new StateInvalidUsageError(_this.path, ErrorId.SetProperty_Value);\n        }, true);\n    };\n    StateMethodsImpl.prototype.valueObjectImpl = function(currentValue) {\n        var _this = this;\n        return proxyWrap(this.path, currentValue, function() {\n            return currentValue;\n        }, function(target, key) {\n            if (key in Object.prototype) {\n                return Object.prototype[key];\n            }\n            if (key === SelfMethodsID) {\n                return _this;\n            }\n            if (typeof key === \"symbol\") {\n                // allow clients to associate hidden cache with state values\n                return target[key];\n            }\n            return _this.child(key).get();\n        }, function(target, key, value) {\n            if (typeof key === \"symbol\") {\n                // allow clients to associate hidden cache with state values\n                target[key] = value;\n                return true;\n            }\n            throw new StateInvalidUsageError(_this.path, ErrorId.SetProperty_Value);\n        }, true);\n    };\n    StateMethodsImpl.prototype.self = function() {\n        var _this = this;\n        if (this.selfUsed) {\n            return this.selfUsed;\n        }\n        var getter = function(_, key) {\n            if (key === self) {\n                return _this;\n            }\n            if (typeof key === \"symbol\") {\n                return undefined;\n            }\n            if (key === \"toJSON\") {\n                throw new StateInvalidUsageError(_this.path, ErrorId.ToJson_State);\n            }\n            var nestedGetter = function(prop) {\n                var currentValue = _this.get({\n                    __internalAllowPromised: prop === \"$$typeof\" || prop === \"constructor\"\n                });\n                if (prop in Object.prototype) {\n                    // Mark it used entirely, so changes to the value\n                    // invalidate and rerender results for Object.prototype.toString(),\n                    // for example.\n                    // We check for Object prototype functions\n                    // even for primitive values, because primitive values still\n                    // can have object methods.\n                    return Object.prototype[prop];\n                }\n                if (Object(currentValue) !== currentValue && // if promised, it will be none\n                currentValue !== none) {\n                    // This was an error case, but various tools like webpack bundler\n                    // and react dev tools attempt to get props out of non-null object,\n                    // so this was changed to return just undefined for any property request\n                    // as there is no way to fix 3rd party tools.\n                    // Logging a warning to console is also not an option\n                    // as it pollutes console for legitimate apps on app start app.\n                    // Ref: https://github.com/avkonst/hookstate/issues/125\n                    return undefined;\n                }\n                if (Array.isArray(currentValue)) {\n                    if (prop === \"length\") {\n                        return currentValue.length;\n                    }\n                    if (prop in Array.prototype) {\n                        return Array.prototype[prop];\n                    }\n                    var index = Number(prop);\n                    if (!Number.isInteger(index)) {\n                        return undefined;\n                    }\n                    return _this.nested(index);\n                }\n                return _this.nested(prop.toString());\n            };\n            switch(key){\n                case \"path\":\n                    return _this.path;\n                case \"keys\":\n                    return _this.keys;\n                case \"value\":\n                    return _this.value;\n                case \"ornull\":\n                    return _this.ornull;\n                case \"promised\":\n                    return _this.promised;\n                case \"promise\":\n                    return _this.promise;\n                case \"error\":\n                    return _this.error;\n                case \"get\":\n                    return function(opts) {\n                        return _this.get(opts);\n                    };\n                case \"set\":\n                    return function(p) {\n                        return _this.set(p);\n                    };\n                case \"merge\":\n                    return function(p) {\n                        return _this.merge(p);\n                    };\n                case \"nested\":\n                    return function(p) {\n                        return nestedGetter(p);\n                    };\n                default:\n                    // check if extension method\n                    var ext = _this.store.extension;\n                    if (ext && key in ext) {\n                        return ext[key](_this.self());\n                    }\n                    // otherwise nested child\n                    return nestedGetter(key);\n            }\n        };\n        this.selfUsed = proxyWrap(this.path, this.valueSource, function(opts) {\n            return _this.get({\n                __internalAllowPromised: true,\n                stealth: opts === null || opts === void 0 ? void 0 : opts.stealth\n            });\n        }, getter, function(_, key, value) {\n            throw new StateInvalidUsageError(_this.path, ErrorId.SetProperty_State);\n        }, false);\n        return this.selfUsed;\n    };\n    Object.defineProperty(StateMethodsImpl.prototype, \"promised\", {\n        get: function() {\n            this.get({\n                __internalAllowPromised: true\n            }); // marks used\n            return !!this.store.promise;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(StateMethodsImpl.prototype, \"promise\", {\n        get: function() {\n            var _this = this;\n            var _a;\n            this.get({\n                __internalAllowPromised: true\n            }); // marks used\n            return (_a = this.store.promise) === null || _a === void 0 ? void 0 : _a.then(function(_) {\n                return _this.self();\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(StateMethodsImpl.prototype, \"error\", {\n        get: function() {\n            this.get({\n                __internalAllowPromised: !!this.store.promiseError\n            }); // marks used\n            return this.store.promiseError;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(StateMethodsImpl.prototype, \"ornull\", {\n        get: function() {\n            var value = this.get();\n            if (value === null || value === undefined) {\n                return value;\n            }\n            return this.self();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return StateMethodsImpl;\n}();\nfunction proxyWrap(path, // tslint:disable-next-line: no-any\ntargetBootstrap, // tslint:disable-next-line: no-any\ntargetGetter, // tslint:disable-next-line: no-any\npropertyGetter, // tslint:disable-next-line: no-any\npropertySetter, isValueProxy) {\n    var onInvalidUsage = function(op) {\n        throw new StateInvalidUsageError(path, op);\n    };\n    if (Object(targetBootstrap) !== targetBootstrap) {\n        targetBootstrap = {};\n    }\n    return new Proxy(targetBootstrap, {\n        getPrototypeOf: function(_target) {\n            // should satisfy the invariants:\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getPrototypeOf#Invariants\n            var targetReal = targetGetter();\n            if (targetReal === undefined || targetReal === null) {\n                return null;\n            }\n            if (targetReal === none) {\n                return Object.getPrototypeOf(new Promise(function() {}));\n            }\n            return Object.getPrototypeOf(targetReal);\n        },\n        setPrototypeOf: function(_target, v) {\n            return onInvalidUsage(isValueProxy ? ErrorId.SetPrototypeOf_State : ErrorId.SetPrototypeOf_Value);\n        },\n        isExtensible: function(_target) {\n            // should satisfy the invariants:\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/isExtensible#Invariants\n            return true; // required to satisfy the invariants of the getPrototypeOf\n        // return Object.isExtensible(target);\n        },\n        preventExtensions: function(_target) {\n            return onInvalidUsage(isValueProxy ? ErrorId.PreventExtensions_State : ErrorId.PreventExtensions_Value);\n        },\n        getOwnPropertyDescriptor: function(_target, p) {\n            var targetReal = targetGetter();\n            if (Object(targetReal) === targetReal) {\n                var origin_1 = Object.getOwnPropertyDescriptor(targetReal, p);\n                if (Array.isArray(targetReal) && p in Array.prototype) {\n                    return origin_1;\n                }\n                return origin_1 && {\n                    // should be configurable as may not exist on proxy target\n                    configurable: true,\n                    enumerable: origin_1.enumerable,\n                    get: function() {\n                        return propertyGetter(targetReal, p);\n                    },\n                    set: undefined\n                };\n            }\n            if (isValueProxy || targetReal === none) {\n                return undefined;\n            }\n            if (p === \"value\") {\n                return {\n                    // should be configurable as does not exist on proxy target\n                    configurable: true,\n                    enumerable: true,\n                    get: function() {\n                        return targetGetter({\n                            stealth: true\n                        });\n                    },\n                    set: undefined\n                };\n            }\n            if (p === \"path\") {\n                return {\n                    // should be configurable as does not exist on proxy target\n                    configurable: true,\n                    enumerable: true,\n                    get: function() {\n                        return path;\n                    },\n                    set: undefined\n                };\n            }\n            return undefined;\n        },\n        has: function(_target, p) {\n            if (typeof p === \"symbol\") {\n                return false;\n            }\n            var targetReal = targetGetter();\n            if (Object(targetReal) === targetReal) {\n                return p in targetReal;\n            }\n            if (isValueProxy || targetReal === none) {\n                return false;\n            }\n            return p === \"value\" || p === \"path\";\n        },\n        get: propertyGetter,\n        set: propertySetter,\n        deleteProperty: function(_target, p) {\n            return onInvalidUsage(isValueProxy ? ErrorId.DeleteProperty_State : ErrorId.DeleteProperty_Value);\n        },\n        defineProperty: function(_target, p, attributes) {\n            return onInvalidUsage(isValueProxy ? ErrorId.DefineProperty_State : ErrorId.DefineProperty_Value);\n        },\n        ownKeys: function(_target) {\n            var targetReal = targetGetter();\n            if (Array.isArray(targetReal)) {\n                if (_target.length === undefined) {\n                    // an object turned into an array now\n                    // inject length property now as it is defined on the array\n                    // to enable getOwnPropertyDescriptor for length not throw\n                    Object.defineProperty(targetBootstrap, \"length\", {\n                        value: 0,\n                        writable: true,\n                        enumerable: false,\n                        configurable: false\n                    });\n                }\n            }\n            if (Object(targetReal) === targetReal) {\n                return Object.getOwnPropertyNames(targetReal);\n            }\n            if (isValueProxy || targetReal === none) {\n                return [];\n            }\n            return [\n                \"value\",\n                \"path\"\n            ];\n        },\n        apply: function(_target, thisArg, argArray) {\n            return onInvalidUsage(isValueProxy ? ErrorId.Apply_State : ErrorId.Apply_Value);\n        },\n        construct: function(_target, argArray, newTarget) {\n            return onInvalidUsage(isValueProxy ? ErrorId.Construct_State : ErrorId.Construct_Value);\n        }\n    });\n}\nfunction createStore(initial) {\n    var initialValue = initial;\n    if (typeof initial === \"function\") {\n        initialValue = initial();\n    }\n    if (Object(initialValue) === initialValue && initialValue[SelfMethodsID]) {\n        throw new StateInvalidUsageError(RootPath, ErrorId.InitStateToValueFromState);\n    }\n    return new Store(initialValue);\n}\nvar configuration = {\n    interceptDependencyListsMode: \"always\",\n    isDevelopmentMode: typeof process === \"object\" && typeof process.env === \"object\" && \"development\" === \"development\",\n    promiseDetector: function(p) {\n        return Promise.resolve(p) === p;\n    },\n    hiddenInterceptDependencyListsModeDebug: false\n};\n/**\n * Configures Hookstate behavior globally. This is for special cases only, when default\n * heuristics fail to work in a specific environment.\n *\n * @param config\n */ function configure(config) {\n    var _a, _b, _c;\n    configuration = {\n        interceptDependencyListsMode: (_a = config.interceptDependencyListsMode) !== null && _a !== void 0 ? _a : configuration.interceptDependencyListsMode,\n        isDevelopmentMode: (_b = config.isDevelopmentMode) !== null && _b !== void 0 ? _b : configuration.isDevelopmentMode,\n        promiseDetector: (_c = config.promiseDetector) !== null && _c !== void 0 ? _c : configuration.promiseDetector,\n        hiddenInterceptDependencyListsModeDebug: false\n    };\n    interceptReactHooks(); // not really required, but for safety\n    if (configuration.interceptDependencyListsMode === \"never\") {\n        configuration.hiddenInterceptDependencyListsModeDebug = false;\n        (react__WEBPACK_IMPORTED_MODULE_0___default().useEffect) = (react__WEBPACK_IMPORTED_MODULE_0___default().useEffect) && useEffectOrigin;\n        (react__WEBPACK_IMPORTED_MODULE_0___default().useLayoutEffect) = (react__WEBPACK_IMPORTED_MODULE_0___default().useLayoutEffect) && useLayoutEffectOrigin;\n        (react__WEBPACK_IMPORTED_MODULE_0___default().useInsertionEffect) = (react__WEBPACK_IMPORTED_MODULE_0___default().useInsertionEffect) && useInsertionEffectOrigin;\n        (react__WEBPACK_IMPORTED_MODULE_0___default().useImperativeHandle) = (react__WEBPACK_IMPORTED_MODULE_0___default().useImperativeHandle) && useImperativeHandleOrigin;\n        (react__WEBPACK_IMPORTED_MODULE_0___default().useMemo) = (react__WEBPACK_IMPORTED_MODULE_0___default().useMemo) && useMemoOrigin;\n        (react__WEBPACK_IMPORTED_MODULE_0___default().useCallback) = (react__WEBPACK_IMPORTED_MODULE_0___default().useCallback) && useCallbackOrigin;\n        // the following does not make an effect as memo calls happen on module load\n        // so it is always set to memoIntercept\n        (react__WEBPACK_IMPORTED_MODULE_0___default().memo) = (react__WEBPACK_IMPORTED_MODULE_0___default().memo) && memoOrigin;\n    } else {\n        // do not intercept if a hook is not defined in React\n        // otherwise, it will enable 3rd party libs thinking the react runs at version 18\n        (react__WEBPACK_IMPORTED_MODULE_0___default().useEffect) = (react__WEBPACK_IMPORTED_MODULE_0___default().useEffect) && useEffectIntercept;\n        (react__WEBPACK_IMPORTED_MODULE_0___default().useLayoutEffect) = (react__WEBPACK_IMPORTED_MODULE_0___default().useLayoutEffect) && useLayoutEffectIntercept;\n        (react__WEBPACK_IMPORTED_MODULE_0___default().useInsertionEffect) = (react__WEBPACK_IMPORTED_MODULE_0___default().useLayoutEffect) && useInsertionEffectIntercept;\n        (react__WEBPACK_IMPORTED_MODULE_0___default().useImperativeHandle) = (react__WEBPACK_IMPORTED_MODULE_0___default().useImperativeHandle) && useImperativeHandleIntercept;\n        (react__WEBPACK_IMPORTED_MODULE_0___default().useMemo) = (react__WEBPACK_IMPORTED_MODULE_0___default().useMemo) && useMemoIntercept;\n        (react__WEBPACK_IMPORTED_MODULE_0___default().useCallback) = (react__WEBPACK_IMPORTED_MODULE_0___default().useCallback) && useCallbackIntercept;\n        // the following does not make an effect as memo calls happen on module load\n        // so it is always set to memoIntercept\n        (react__WEBPACK_IMPORTED_MODULE_0___default().memo) = (react__WEBPACK_IMPORTED_MODULE_0___default().memo) && memoIntercept;\n        if (configuration.interceptDependencyListsMode === \"development\" && configuration.isDevelopmentMode) {\n            configuration.hiddenInterceptDependencyListsModeDebug = true;\n        }\n    }\n}\nfunction reconnectDependencies(deps, fromIntercept) {\n    for(var _i = 0, _a = deps || []; _i < _a.length; _i++){\n        var i = _a[_i];\n        if (i === Object(i)) {\n            var state = i[self];\n            if (state) {\n                if (fromIntercept && configuration.hiddenInterceptDependencyListsModeDebug) {\n                    throw new StateInvalidUsageError(state.path, ErrorId.StateUsedInDependencyList);\n                }\n                state.reconnect();\n            }\n        }\n    }\n    return deps;\n}\nvar useEffectOrigin;\nfunction useHookstateEffect(effect, deps) {\n    reconnectDependencies(deps);\n    return useEffectOrigin(effect, deps);\n}\nfunction useEffectIntercept(effect, deps) {\n    reconnectDependencies(deps, true);\n    return useEffectOrigin(effect, deps);\n}\nvar useLayoutEffectOrigin;\nfunction useHookstateLayoutEffect(effect, deps) {\n    reconnectDependencies(deps);\n    return useLayoutEffectOrigin(effect, deps);\n}\nfunction useLayoutEffectIntercept(effect, deps) {\n    reconnectDependencies(deps, true);\n    return useLayoutEffectOrigin(effect, deps);\n}\nvar useInsertionEffectOrigin;\nfunction useHookstateInsertionEffect(effect, deps) {\n    reconnectDependencies(deps);\n    return useInsertionEffectOrigin(effect, deps);\n}\nfunction useInsertionEffectIntercept(effect, deps) {\n    reconnectDependencies(deps, true);\n    return useInsertionEffectOrigin(effect, deps);\n}\nvar useImperativeHandleOrigin;\nfunction useHookstateImperativeHandle(ref, init, deps) {\n    reconnectDependencies(deps);\n    return useImperativeHandleOrigin(ref, init, deps);\n}\nfunction useImperativeHandleIntercept(ref, init, deps) {\n    reconnectDependencies(deps, true);\n    return useImperativeHandleOrigin(ref, init, deps);\n}\nvar useMemoOrigin;\nfunction useHookstateMemo(factory, deps) {\n    reconnectDependencies(deps);\n    return useMemoOrigin(factory, deps);\n}\nfunction useMemoIntercept(factory, deps) {\n    reconnectDependencies(deps, true);\n    return useMemoOrigin(factory, deps);\n}\nvar useCallbackOrigin;\nfunction useHookstateCallback(callback, deps) {\n    reconnectDependencies(deps);\n    return useCallbackOrigin(callback, deps);\n}\nfunction useCallbackIntercept(callback, deps) {\n    reconnectDependencies(deps, true);\n    return useCallbackOrigin(callback, deps);\n}\nvar memoOrigin;\nfunction hookstateMemo(Component, propsAreEqual) {\n    return memoOrigin(Component, function(prevProps, nextProps) {\n        reconnectDependencies(Object.keys(nextProps).map(function(i) {\n            return nextProps[i];\n        }));\n        return (propsAreEqual || shallowEqual)(prevProps, nextProps);\n    });\n}\nfunction memoIntercept(Component, propsAreEqual) {\n    return memoOrigin(Component, function(prevProps, nextProps) {\n        reconnectDependencies(Object.keys(nextProps).map(function(i) {\n            return nextProps[i];\n        }), true);\n        return (propsAreEqual || shallowEqual)(prevProps, nextProps);\n    });\n}\nfunction interceptReactHooks() {\n    if (!useEffectOrigin && (react__WEBPACK_IMPORTED_MODULE_0___default().useEffect)) {\n        useEffectOrigin = (react__WEBPACK_IMPORTED_MODULE_0___default().useEffect);\n        (react__WEBPACK_IMPORTED_MODULE_0___default().useEffect) = useEffectIntercept;\n    }\n    if (!useLayoutEffectOrigin && (react__WEBPACK_IMPORTED_MODULE_0___default().useLayoutEffect)) {\n        useLayoutEffectOrigin = (react__WEBPACK_IMPORTED_MODULE_0___default().useLayoutEffect);\n        (react__WEBPACK_IMPORTED_MODULE_0___default().useLayoutEffect) = useLayoutEffectIntercept;\n    }\n    if (!useInsertionEffectOrigin && (react__WEBPACK_IMPORTED_MODULE_0___default().useInsertionEffect)) {\n        useInsertionEffectOrigin = (react__WEBPACK_IMPORTED_MODULE_0___default().useInsertionEffect);\n        (react__WEBPACK_IMPORTED_MODULE_0___default().useInsertionEffect) = useInsertionEffectIntercept;\n    }\n    if (!useImperativeHandleOrigin && (react__WEBPACK_IMPORTED_MODULE_0___default().useImperativeHandle)) {\n        useImperativeHandleOrigin = (react__WEBPACK_IMPORTED_MODULE_0___default().useImperativeHandle);\n        (react__WEBPACK_IMPORTED_MODULE_0___default().useImperativeHandle) = useImperativeHandleIntercept;\n    }\n    if (!useMemoOrigin && (react__WEBPACK_IMPORTED_MODULE_0___default().useMemo)) {\n        useMemoOrigin = (react__WEBPACK_IMPORTED_MODULE_0___default().useMemo);\n        (react__WEBPACK_IMPORTED_MODULE_0___default().useMemo) = useMemoIntercept;\n    }\n    if (!useCallbackOrigin && (react__WEBPACK_IMPORTED_MODULE_0___default().useCallback)) {\n        useCallbackOrigin = (react__WEBPACK_IMPORTED_MODULE_0___default().useCallback);\n        (react__WEBPACK_IMPORTED_MODULE_0___default().useCallback) = useCallbackIntercept;\n    }\n    if (!memoOrigin && (react__WEBPACK_IMPORTED_MODULE_0___default().memo)) {\n        memoOrigin = (react__WEBPACK_IMPORTED_MODULE_0___default().memo);\n        (react__WEBPACK_IMPORTED_MODULE_0___default().memo) = memoIntercept;\n    }\n}\ninterceptReactHooks(); // TODO defer invoking it until state is created, so the configure had a chance to set it up first\n// Do not try to use useLayoutEffect if DOM not available (SSR)\nvar useIsomorphicLayoutEffect =  false ? 0 : useEffectOrigin;\n //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGhvb2tzdGF0ZS9jb3JlL2Rpc3QvaW5kZXguZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEI7QUFFMUI7Ozs7Ozs7Ozs7Ozs7OEVBYThFLEdBQzlFLDJCQUEyQixHQUUzQixJQUFJQyxnQkFBZ0IsU0FBU0MsQ0FBQyxFQUFFQyxDQUFDO0lBQzdCRixnQkFBZ0JHLE9BQU9DLGNBQWMsSUFDaEM7UUFBRUMsV0FBVyxFQUFFO0lBQUMsY0FBYUMsU0FBUyxTQUFVTCxDQUFDLEVBQUVDLENBQUM7UUFBSUQsRUFBRUksU0FBUyxHQUFHSDtJQUFHLEtBQzFFLFNBQVVELENBQUMsRUFBRUMsQ0FBQztRQUFJLElBQUssSUFBSUssS0FBS0wsRUFBRyxJQUFJQyxPQUFPSyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUixHQUFHSyxJQUFJTixDQUFDLENBQUNNLEVBQUUsR0FBR0wsQ0FBQyxDQUFDSyxFQUFFO0lBQUU7SUFDcEcsT0FBT1AsY0FBY0MsR0FBR0M7QUFDNUI7QUFFQSxTQUFTUyxVQUFVVixDQUFDLEVBQUVDLENBQUM7SUFDbkIsSUFBSSxPQUFPQSxNQUFNLGNBQWNBLE1BQU0sTUFDakMsTUFBTSxJQUFJVSxVQUFVLHlCQUF5QkMsT0FBT1gsS0FBSztJQUM3REYsY0FBY0MsR0FBR0M7SUFDakIsU0FBU1k7UUFBTyxJQUFJLENBQUNDLFdBQVcsR0FBR2Q7SUFBRztJQUN0Q0EsRUFBRU8sU0FBUyxHQUFHTixNQUFNLE9BQU9DLE9BQU9hLE1BQU0sQ0FBQ2QsS0FBTVksQ0FBQUEsR0FBR04sU0FBUyxHQUFHTixFQUFFTSxTQUFTLEVBQUUsSUFBSU0sSUFBRztBQUN0RjtBQUVBLElBQUlHLFdBQVc7SUFDWEEsV0FBV2QsT0FBT2UsTUFBTSxJQUFJLFNBQVNELFNBQVNFLENBQUM7UUFDM0MsSUFBSyxJQUFJQyxHQUFHQyxJQUFJLEdBQUdDLElBQUlDLFVBQVVDLE1BQU0sRUFBRUgsSUFB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LHdEQUFrQjtRQUNwQ0Esd0RBQWtCLEdBQUcwVDtJQUN6QjtJQUNBLElBQUksQ0FBQ04seUJBQXlCcFQsOERBQXdCLEVBQUU7UUFDcERvVCx3QkFBd0JwVCw4REFBd0I7UUFDaERBLDhEQUF3QixHQUFHMlQ7SUFDL0I7SUFDQSxJQUFJLENBQUNOLDRCQUE0QnJULGlFQUEyQixFQUFFO1FBQzFEcVQsMkJBQTJCclQsaUVBQTJCO1FBQ3REQSxpRUFBMkIsR0FBRzRUO0lBQ2xDO0lBQ0EsSUFBSSxDQUFDTiw2QkFBNkJ0VCxrRUFBNEIsRUFBRTtRQUM1RHNULDRCQUE0QnRULGtFQUE0QjtRQUN4REEsa0VBQTRCLEdBQUc2VDtJQUNuQztJQUNBLElBQUksQ0FBQ04saUJBQWlCdlQsc0RBQWdCLEVBQUU7UUFDcEN1VCxnQkFBZ0J2VCxzREFBZ0I7UUFDaENBLHNEQUFnQixHQUFHOFQ7SUFDdkI7SUFDQSxJQUFJLENBQUNOLHFCQUFxQnhULDBEQUFvQixFQUFFO1FBQzVDd1Qsb0JBQW9CeFQsMERBQW9CO1FBQ3hDQSwwREFBb0IsR0FBRytUO0lBQzNCO0lBQ0EsSUFBSSxDQUFDTixjQUFjelQsbURBQWEsRUFBRTtRQUM5QnlULGFBQWF6VCxtREFBYTtRQUMxQkEsbURBQWEsR0FBR2dVO0lBQ3BCO0FBQ0o7QUFDQWQsdUJBQXVCLGtHQUFrRztBQUN6SCwrREFBK0Q7QUFDL0QsSUFBSWpNLDRCQUE0QixNQUFrQixHQUFjbU0sQ0FBcUJBLEdBQUdEO0FBRTZNLENBQ3JTLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hZ2ljLWNvbHVtbnMvLi9ub2RlX21vZHVsZXMvQGhvb2tzdGF0ZS9jb3JlL2Rpc3QvaW5kZXguZXMuanM/MDkyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XG5cbi8qKlxuICogQ29waWVkIGZyb20gZmJqcyBpcy1zaGFsbG93LWVxdWFsXG4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7IC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgICAvLyBBZGRlZCB0aGUgbm9uemVybyB5IGNoZWNrIHRvIG1ha2UgRmxvdyBoYXBweSwgYnV0IGl0IGlzIHJlZHVuZGFudFxuICAgICAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxufVxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICovXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICAgIGlmIChpcyhvYmpBLCBvYmpCKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8XG4gICAgICAgIHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG4gICAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHxcbiAgICAgICAgICAgICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogU3BlY2lhbCBzeW1ib2wgd2hpY2ggbWlnaHQgYmUgdXNlZCB0byBkZWxldGUgcHJvcGVydGllc1xuICogZnJvbSBhbiBvYmplY3QgY2FsbGluZyBbU3RhdGUuc2V0XSgjc2V0KSBvciBbU3RhdGUubWVyZ2VdKCNtZXJnZSkuXG4gKlxuICogW0xlYXJuIG1vcmUuLi5dKGh0dHBzOi8vaG9va3N0YXRlLmpzLm9yZy9kb2NzL25lc3RlZC1zdGF0ZSNkZWxldGluZy1leGlzdGluZy1lbGVtZW50KVxuICovXG52YXIgbm9uZSA9IFN5bWJvbCgnbm9uZScpO1xuLy8gdHlwZSBQaWNrQnlUeXBlPFQsIFUsIEIgPSBmYWxzZT4gPSBQaWNrPFQsIEtleXNPZlR5cGU8VCwgVSwgQj4+O1xuLyoqXG4gKiBBIHN5bWJvbCB3aGljaCBpcyB1c2VkIGZvciB0eXBlIGluZmVyZW5jZSBtYXJraW5nLlxuICpcbiAqIEBoaWRkZW5cbiAqIEBpZ25vcmVcbiAqL1xudmFyIF9fc3RhdGUgPSBTeW1ib2woJ19fc3RhdGUnKTtcbmZ1bmN0aW9uIGhvb2tzdGF0ZShpbml0aWFsLCBleHRlbnNpb24pIHtcbiAgICB2YXIgc3RvcmUgPSBjcmVhdGVTdG9yZShpbml0aWFsKTtcbiAgICBzdG9yZS5hY3RpdmF0ZShleHRlbnNpb24pO1xuICAgIHZhciBtZXRob2RzID0gc3RvcmUudG9NZXRob2RzKCk7XG4gICAgcmV0dXJuIG1ldGhvZHMuc2VsZigpO1xufVxuLyoqXG4gKiBBIG1ldGhvZCB0byBkZXN0cm95IGEgZ2xvYmFsIHN0YXRlIGFuZCByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IHRoZSBleHRlbnNpb25zXG4gKi9cbmZ1bmN0aW9uIGRlc3Ryb3koc3RhdGUpIHtcbiAgICBzdGF0ZVtzZWxmXS5kZWFjdGl2YXRlKCk7XG59XG4vKipcbiAqIEEgbWV0aG9kIHRvIGNoZWNrIGlmIGEgdmFyaWFibGUgaXMgYW4gaW5zdGFuY2Ugb2YgSG9va3N0YXRlIFN0YXRlXG4gKi9cbmZ1bmN0aW9uIGlzSG9va3N0YXRlKHYpIHtcbiAgICByZXR1cm4gISEodiA9PT0gbnVsbCB8fCB2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2W3NlbGZdKTtcbn1cbi8qKlxuICogQSBtZXRob2QgdG8gY2hlY2sgaWYgYSB2YXJpYWJsZSBpcyBhbiBpbnN0YW5jZSBvZiB0cmFjZWQgKHdyYXBwZWQgaW4gYSBwcm94eSkgSG9va3N0YXRlIFZhbHVlXG4gKi9cbmZ1bmN0aW9uIGlzSG9va3N0YXRlVmFsdWUodikge1xuICAgIHJldHVybiAhISh2ID09PSBudWxsIHx8IHYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZbU2VsZk1ldGhvZHNJRF0pO1xufVxuLyoqXG4gKiBBIGZ1bmN0aW9uIGNvbWJpbmVzIG11bHRpcGxlIGV4dGVuc2lvbnMgaW50byBvbmUgZXh0ZW5zaW9uIGFuZCByZXR1cm5zIGl0XG4gKiBCcm93c2UgYW4gZXhhbXBsZSBbaGVyZV0oaHR0cHM6Ly9ob29rc3RhdGUuanMub3JnL2RvY3MvZXh0ZW5zaW9ucy1zbmFwc2hvdGFibGUpXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChlMSwgZTIsIGUzLCBlNCwgZTUpIHtcbiAgICBmdW5jdGlvbiBleHRlbmRlZChleHRlbnNpb25zKSB7XG4gICAgICAgIHZhciBleHRzID0gZXh0ZW5zaW9ucy5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkoKTsgfSk7XG4gICAgICAgIHZhciBvbkluaXRDYnMgPSBleHRzLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gaS5vbkluaXQ7IH0pLmZpbHRlcihmdW5jdGlvbiAoaSkgeyByZXR1cm4gaTsgfSk7XG4gICAgICAgIHZhciBvblByZW1lcmdlQ2JzID0gZXh0cy5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkub25QcmVtZXJnZTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChpKSB7IHJldHVybiBpOyB9KTtcbiAgICAgICAgdmFyIG9uUHJlc2V0Q2JzID0gZXh0cy5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkub25QcmVzZXQ7IH0pLmZpbHRlcihmdW5jdGlvbiAoaSkgeyByZXR1cm4gaTsgfSk7XG4gICAgICAgIHZhciBvblNldENicyA9IGV4dHMubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLm9uU2V0OyB9KS5maWx0ZXIoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGk7IH0pO1xuICAgICAgICB2YXIgb25EZXN0cm95Q2JzID0gZXh0cy5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkub25EZXN0cm95OyB9KS5maWx0ZXIoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGk7IH0pO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgb25DcmVhdGU6IGZ1bmN0aW9uIChpbnN0YW5jZUZhY3RvcnksIGNvbWJpbmVkTWV0aG9kcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgZXh0c18xID0gZXh0czsgX2kgPCBleHRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleHQgPSBleHRzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0Lm9uQ3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXh0TWV0aG9kcyA9IGV4dC5vbkNyZWF0ZShpbnN0YW5jZUZhY3RvcnksIGNvbWJpbmVkTWV0aG9kcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGNvbWJpbmVkTWV0aG9kcywgZXh0TWV0aG9kcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbWJpbmVkTWV0aG9kcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9uSW5pdENicy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQub25Jbml0ID0gZnVuY3Rpb24gKHMsIGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG9uSW5pdENic18xID0gb25Jbml0Q2JzOyBfaSA8IG9uSW5pdENic18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2IgPSBvbkluaXRDYnNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGNiKHMsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUHJlbWVyZ2VDYnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0Lm9uUHJlbWVyZ2UgPSBmdW5jdGlvbiAocywgZCwgcikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgb25QcmVtZXJnZUNic18xID0gb25QcmVtZXJnZUNiczsgX2kgPCBvblByZW1lcmdlQ2JzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYiA9IG9uUHJlbWVyZ2VDYnNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGNiKHMsIGQsIHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUHJlc2V0Q2JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5vblByZXNldCA9IGZ1bmN0aW9uIChzLCBkLCByKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBvblByZXNldENic18xID0gb25QcmVzZXRDYnM7IF9pIDwgb25QcmVzZXRDYnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNiID0gb25QcmVzZXRDYnNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGNiKHMsIGQsIHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uU2V0Q2JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5vblNldCA9IGZ1bmN0aW9uIChzLCBkLCByKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBvblNldENic18xID0gb25TZXRDYnM7IF9pIDwgb25TZXRDYnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNiID0gb25TZXRDYnNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGNiKHMsIGQsIHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRGVzdHJveUNicy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQub25EZXN0cm95ID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG9uRGVzdHJveUNic18xID0gb25EZXN0cm95Q2JzOyBfaSA8IG9uRGVzdHJveUNic18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2IgPSBvbkRlc3Ryb3lDYnNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGNiKHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4dGVuZGVkKFtlMSwgZTIsIGUzLCBlNCwgZTVdLmZpbHRlcihmdW5jdGlvbiAoaSkgeyByZXR1cm4gaTsgfSkpOyB9O1xufVxuZnVuY3Rpb24gdXNlSG9va3N0YXRlKHNvdXJjZSwgZXh0ZW5zaW9uKSB7XG4gICAgdmFyIHBhcmVudE1ldGhvZHMgPSBPYmplY3Qoc291cmNlKSA9PT0gc291cmNlID9cbiAgICAgICAgc291cmNlW3NlbGZdIDpcbiAgICAgICAgdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnRNZXRob2RzKSB7XG4gICAgICAgIGlmIChwYXJlbnRNZXRob2RzLmlzTW91bnRlZCkge1xuICAgICAgICAgICAgLy8gU2NvcGVkIHN0YXRlIG1vdW50XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAgICAgICAgIHZhciBpbml0aWFsaXplciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyB3YXJuaW5nOiB0aGlzIGlzIGNhbGxlZCB0d2ljZSBpbiByZWFjdCBzdHJpY3QgbW9kZVxuICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHBhcmVudE1ldGhvZHMuc3RvcmU7XG4gICAgICAgICAgICAgICAgdmFyIG9uU2V0VXNlZENhbGxiYWNrID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2V0VmFsdWVfMSh7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlOiBzdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHZhbHVlXzEuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRNZXRob2RzOiBwYXJlbnRNZXRob2RzXG4gICAgICAgICAgICAgICAgfSk7IH07XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gbmV3IFN0YXRlTWV0aG9kc0ltcGwoc3RvcmUsIHBhcmVudE1ldGhvZHMucGF0aCwgc3RvcmUuZ2V0KHBhcmVudE1ldGhvZHMucGF0aCksIHN0b3JlLmVkaXRpb24sIG9uU2V0VXNlZENhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZTogc3RvcmUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE1ldGhvZHM6IHBhcmVudE1ldGhvZHNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfYSA9IFJlYWN0LnVzZVN0YXRlKGluaXRpYWxpemVyKSwgdmFsdWVfMSA9IF9hWzBdLCBzZXRWYWx1ZV8xID0gX2FbMV07XG4gICAgICAgICAgICBpZiAodmFsdWVfMS5zdG9yZSAhPT0gcGFyZW50TWV0aG9kcy5zdG9yZSB8fCAhKCdzb3VyY2UnIGluIHZhbHVlXzEpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVfMS5zdGF0ZS5vblVubW91bnQoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZV8xLnBhcmVudE1ldGhvZHMudW5zdWJzY3JpYmUodmFsdWVfMS5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgdmFsdWVfMSA9IGluaXRpYWxpemVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPIG1vdmUgdG8gYSBjbGFzcyBoaWRlIHByb3BzIG9uIHByb3RvdHlwZSBsZXZlbFxuICAgICAgICAgICAgLy8gaGlkZSBwcm9wcyBmcm9tIGRldmVsb3BtZW50IHRvb2xzXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWVfMSwgJ3N0b3JlJywgeyBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZV8xLCAnc3RhdGUnLCB7IGVudW1lcmFibGU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlXzEsICdzb3VyY2UnLCB7IGVudW1lcmFibGU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlXzEsICdwYXJlbnRNZXRob2RzJywgeyBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHZhbHVlXzEuc3RhdGUucmVjb25zdHJ1Y3QocGFyZW50TWV0aG9kcy5wYXRoLCB2YWx1ZV8xLnN0b3JlLmdldChwYXJlbnRNZXRob2RzLnBhdGgpLCB2YWx1ZV8xLnN0b3JlLmVkaXRpb24sIFxuICAgICAgICAgICAgLy8gcGFyZW50IHN0YXRlIG9iamVjdCBoYXMgY2hhbmdlZCBpdHMgcmVmZXJlbmNlIG9iamVjdFxuICAgICAgICAgICAgLy8gc28gdGhlIHNjb3BwZWQgc3RhdGUgc2hvdWxkIGNoYW5nZSB0b29cbiAgICAgICAgICAgIHZhbHVlXzEuc291cmNlICE9PSBzb3VyY2UpO1xuICAgICAgICAgICAgdmFsdWVfMS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgICAgICAvLyBuZWVkIHRvIHN1YnNjcmliZSBpbiBzeW5jIG1vZGUsIGJlY2F1c2VcbiAgICAgICAgICAgIC8vIHNhZmFyaSBkZWxheXMgY2FsbGluZyB0aGUgZWZmZWN0IGdpdmluZyBwcmlvcml0eSB0byB0aW1lb3V0cyBhbmQgbmV0d29yayBldmVudHMsXG4gICAgICAgICAgICAvLyB3aGljaCBjYW4gY2F1c2UgdGhlIHN0YXRlIHVwZGF0ZVxuICAgICAgICAgICAgcGFyZW50TWV0aG9kcy5zdWJzY3JpYmUodmFsdWVfMS5zdGF0ZSk7IC8vIG5vLW9wIGlmIGFscmVhZHkgc3Vic2NyaWJlZFxuICAgICAgICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gd2FybmluZzogaW4gc3RyaWN0IG1vZGUsIGVmZmVjdCBpcyBjYWxsZWQgdHdpY2VcbiAgICAgICAgICAgICAgICAvLyBzbyBuZWVkIHRvIHJlc3RvcmUgc3Vic2NyaXB0aW9uIGFuZCByZWNvbnN0cnVjdCB0aGUgZXh0ZW5zaW9uXG4gICAgICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIGZpcnN0IGVmZmVjdCB1bm1vdW50IGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgdmFsdWVfMS5zdGF0ZS5vbk1vdW50KCk7IC8vIG5vLW9wIGlmIGFscmVhZHkgbW91bnRlZFxuICAgICAgICAgICAgICAgIHBhcmVudE1ldGhvZHMuc3Vic2NyaWJlKHZhbHVlXzEuc3RhdGUpOyAvLyBuby1vcCBpZiBhbHJlYWR5IHN1YnNjcmliZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZV8xLnN0YXRlLm9uVW5tb3VudCgpO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRNZXRob2RzLnVuc3Vic2NyaWJlKHZhbHVlXzEuc3RhdGUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB2YWx1ZV8xLnN0YXRlLnNlbGYoKTtcbiAgICAgICAgICAgIC8vIGV4cG9zZSBwcm9wZXJ0eSBpbiBkZXZlbG9wbWVudCB0b29sc1xuICAgICAgICAgICAgdmFsdWVfMVsnW2hvb2tzdGF0ZShzY29wZWQpXSddID0gc3RhdGU7IC8vIFRPRE8gdXNlIGxhYmVsIGhlcmUsIGFkZCBjb3JlIGV4dGVuc2lvbiB0byBsYWJlbCBzdGF0ZXNcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEdsb2JhbCBzdGF0ZSBtb3VudCBvciBkZXN0cm95ZWQgbGlua1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gd2FybmluZzogdGhpcyBpcyBjYWxsZWQgdHdpY2UgaW4gcmVhY3Qgc3RyaWN0IG1vZGVcbiAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSBwYXJlbnRNZXRob2RzLnN0b3JlO1xuICAgICAgICAgICAgICAgIHZhciBvblNldFVzZWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlXzIuc3RhdGUuaXNNb3VudGVkICYmIHNldFZhbHVlXzIoe1xuICAgICAgICAgICAgICAgICAgICBzdG9yZTogc3RvcmUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiB2YWx1ZV8yLnNvdXJjZSAvLyBtdXRhYmxlLCBnZXQgdGhlIGxhdGVzdCBmcm9tIHZhbHVlXG4gICAgICAgICAgICAgICAgfSk7IH07XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gbmV3IFN0YXRlTWV0aG9kc0ltcGwoc3RvcmUsIFJvb3RQYXRoLCBzdG9yZS5nZXQoUm9vdFBhdGgpLCBzdG9yZS5lZGl0aW9uLCBvblNldFVzZWRDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmU6IHN0b3JlLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX2IgPSBSZWFjdC51c2VTdGF0ZShpbml0aWFsaXplciksIHZhbHVlXzIgPSBfYlswXSwgc2V0VmFsdWVfMiA9IF9iWzFdO1xuICAgICAgICAgICAgaWYgKHZhbHVlXzIuc3RvcmUgIT09IHBhcmVudE1ldGhvZHMuc3RvcmUgfHwgISgnc291cmNlJyBpbiB2YWx1ZV8yKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlXzIuc3RhdGUub25Vbm1vdW50KCk7XG4gICAgICAgICAgICAgICAgdmFsdWVfMi5zdG9yZS51bnN1YnNjcmliZSh2YWx1ZV8yLnN0YXRlKTtcbiAgICAgICAgICAgICAgICB2YWx1ZV8yID0gaW5pdGlhbGl6ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhpZGUgcHJvcHMgZnJvbSBkZXZlbG9wbWVudCB0b29sc1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlXzIsICdzdG9yZScsIHsgZW51bWVyYWJsZTogZmFsc2UgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWVfMiwgJ3N0YXRlJywgeyBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZV8yLCAnc291cmNlJywgeyBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHZhbHVlXzIuc3RhdGUucmVjb25zdHJ1Y3QoUm9vdFBhdGgsIHZhbHVlXzIuc3RvcmUuZ2V0KFJvb3RQYXRoKSwgdmFsdWVfMi5zdG9yZS5lZGl0aW9uLCBcbiAgICAgICAgICAgIC8vIHBhcmVudCBzdGF0ZSBvYmplY3QgaGFzIGNoYW5nZWQgaXRzIHJlZmVyZW5jZSBvYmplY3RcbiAgICAgICAgICAgIC8vIHNvIHRoZSBzY29wcGVkIHN0YXRlIHNob3VsZCBjaGFuZ2UgdG9vXG4gICAgICAgICAgICB2YWx1ZV8yLnNvdXJjZSAhPT0gc291cmNlKTtcbiAgICAgICAgICAgIHZhbHVlXzIuc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgLy8gbmVlZCB0byBzdWJzY3JpYmUgaW4gc3luYyBtb2RlLCBiZWNhdXNlXG4gICAgICAgICAgICAvLyBzYWZhcmkgZGVsYXlzIGNhbGxpbmcgdGhlIGVmZmVjdCBnaXZpbmcgcHJpb3JpdHkgdG8gdGltZW91dHMgYW5kIG5ldHdvcmsgZXZlbnRzLFxuICAgICAgICAgICAgLy8gd2hpY2ggY2FuIGNhdXNlIHRoZSBzdGF0ZSB1cGRhdGVcbiAgICAgICAgICAgIHZhbHVlXzIuc3RvcmUuc3Vic2NyaWJlKHZhbHVlXzIuc3RhdGUpOyAvLyBuby1vcCBpZiBhbHJlYWR5IHN1YnNjcmliZWRcbiAgICAgICAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIHdhcm5pbmc6IGluIHN0cmljdCBtb2RlLCBlZmZlY3QgaXMgY2FsbGVkIHR3aWNlXG4gICAgICAgICAgICAgICAgLy8gc28gbmVlZCB0byByZXN0b3JlIHN1YnNjcmlwdGlvbiBhbmQgcmVjb25zdHJ1Y3QgdGhlIGV4dGVuc2lvblxuICAgICAgICAgICAgICAgIC8vIGFmdGVyIHRoZSBmaXJzdCBlZmZlY3QgdW5tb3VudCBjYWxsYmFja1xuICAgICAgICAgICAgICAgIHZhbHVlXzIuc3RhdGUub25Nb3VudCgpOyAvLyBuby1vcCBpZiBhbHJlYWR5IG1vdW50ZWRcbiAgICAgICAgICAgICAgICB2YWx1ZV8yLnN0b3JlLnN1YnNjcmliZSh2YWx1ZV8yLnN0YXRlKTsgLy8gbm8tb3AgaWYgYWxyZWFkeSBzdWJzY3JpYmVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVfMi5zdGF0ZS5vblVubW91bnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVfMi5zdG9yZS51bnN1YnNjcmliZSh2YWx1ZV8yLnN0YXRlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gdmFsdWVfMi5zdGF0ZS5zZWxmKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmQgPSAwOyBpbmQgPCBwYXJlbnRNZXRob2RzLnBhdGgubGVuZ3RoOyBpbmQgKz0gMSkge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhdGUubmVzdGVkKHBhcmVudE1ldGhvZHMucGF0aFtpbmRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGV4cG9zZSBwcm9wZXJ0eSBpbiBkZXZlbG9wbWVudCB0b29sc1xuICAgICAgICAgICAgdmFsdWVfMlsnW2hvb2tzdGF0ZShnbG9iYWwpXSddID0gc3RhdGU7IC8vIFRPRE8gdXNlIGxhYmVsIGhlcmUsIGFkZCBjb3JlIGV4dGVuc2lvbiB0byBsYWJlbCBzdGF0ZXNcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTG9jYWwgc3RhdGUgbW91bnRcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIHZhciBpbml0aWFsaXplciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHdhcm5pbmc6IHRoaXMgaXMgY2FsbGVkIHR3aWNlIGluIHJlYWN0IHN0cmljdCBtb2RlXG4gICAgICAgICAgICB2YXIgc3RvcmUgPSBjcmVhdGVTdG9yZShzb3VyY2UpO1xuICAgICAgICAgICAgdmFyIG9uU2V0VXNlZENhbGxiYWNrID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWVfMy5zdGF0ZS5pc01vdW50ZWQgJiYgc2V0VmFsdWVfMyh7XG4gICAgICAgICAgICAgICAgc3RvcmU6IHN0b3JlLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIH0pOyB9O1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gbmV3IFN0YXRlTWV0aG9kc0ltcGwoc3RvcmUsIFJvb3RQYXRoLCBzdG9yZS5nZXQoUm9vdFBhdGgpLCBzdG9yZS5lZGl0aW9uLCBvblNldFVzZWRDYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0b3JlOiBzdG9yZSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHZhciBfYyA9IFJlYWN0LnVzZVN0YXRlKGluaXRpYWxpemVyKSwgdmFsdWVfMyA9IF9jWzBdLCBzZXRWYWx1ZV8zID0gX2NbMV07XG4gICAgICAgIGlmICgnc291cmNlJyBpbiB2YWx1ZV8zKSB7XG4gICAgICAgICAgICB2YWx1ZV8zLnN0YXRlLm9uVW5tb3VudCgpO1xuICAgICAgICAgICAgdmFsdWVfMy5zdG9yZS51bnN1YnNjcmliZSh2YWx1ZV8zLnN0YXRlKTtcbiAgICAgICAgICAgIHZhbHVlXzMuc3RvcmUuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgdmFsdWVfMyA9IGluaXRpYWxpemVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGlkZSBwcm9wcyBmcm9tIGRldmVsb3BtZW50IHRvb2xzXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZV8zLCAnc3RvcmUnLCB7IGVudW1lcmFibGU6IGZhbHNlIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWVfMywgJ3N0YXRlJywgeyBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcbiAgICAgICAgdmFsdWVfMy5zdGF0ZS5yZWNvbnN0cnVjdChSb290UGF0aCwgdmFsdWVfMy5zdG9yZS5nZXQoUm9vdFBhdGgpLCB2YWx1ZV8zLnN0b3JlLmVkaXRpb24sIGZhbHNlKTtcbiAgICAgICAgLy8gbmVlZCB0byBzdWJzY3JpYmUgaW4gc3luYyBtb2RlLCBiZWNhdXNlXG4gICAgICAgIC8vIHNhZmFyaSBkZWxheXMgY2FsbGluZyB0aGUgZWZmZWN0IGdpdmluZyBwcmlvcml0eSB0byB0aW1lb3V0cyBhbmQgbmV0d29yayBldmVudHMsXG4gICAgICAgIC8vIHdoaWNoIGNhbiBjYXVzZSB0aGUgc3RhdGUgdXBkYXRlXG4gICAgICAgIHZhbHVlXzMuc3RvcmUuc3Vic2NyaWJlKHZhbHVlXzMuc3RhdGUpOyAvLyBuby1vcCBpZiBhbHJlYWR5IHN1YnNjcmliZWRcbiAgICAgICAgLy8gbmVlZCB0byBhdHRhY2ggdGhlIGV4dGVuc2lvbiBzdHJhaWdodCBhd2F5XG4gICAgICAgIC8vIGJlY2F1c2UgZXh0ZW5zaW9uIG1ldGhvZHMgYXJlIHVzZWQgaW4gcmVuZGVyIGZ1bmN0aW9uXG4gICAgICAgIC8vIGFuZCB3ZSBjYW4gbm90IGRlZmVyIGl0IHRvIHRoZSBlZmZlY3QgY2FsbGJhY2tcbiAgICAgICAgdmFsdWVfMy5zdG9yZS5hY3RpdmF0ZShleHRlbnNpb24pOyAvLyBuby1vcCBpZiBhbHJlYWR5IGF0dGFjaGVkXG4gICAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gd2FybmluZzogaW4gc3RyaWN0IG1vZGUsIGVmZmVjdCBpcyBjYWxsZWQgdHdpY2VcbiAgICAgICAgICAgIC8vIHNvIG5lZWQgdG8gcmVzdG9yZSBzdWJzY3JpcHRpb24gYW5kIHJlY29uc3RydWN0IHRoZSBleHRlbnNpb25cbiAgICAgICAgICAgIC8vIGFmdGVyIHRoZSBmaXJzdCBlZmZlY3QgdW5tb3VudCBjYWxsYmFja1xuICAgICAgICAgICAgdmFsdWVfMy5zdGF0ZS5vbk1vdW50KCk7IC8vIG5vLW9wIGlmIGFscmVhZHkgbW91bnRlZFxuICAgICAgICAgICAgdmFsdWVfMy5zdG9yZS5zdWJzY3JpYmUodmFsdWVfMy5zdGF0ZSk7IC8vIG5vLW9wIGlmIGFscmVhZHkgc3Vic2NyaWJlZFxuICAgICAgICAgICAgdmFsdWVfMy5zdG9yZS5hY3RpdmF0ZShleHRlbnNpb24pOyAvLyBuby1vcCBpZiBhbHJlYWR5IGF0dGFjaGVkXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhbHVlXzMuc3RhdGUub25Vbm1vdW50KCk7XG4gICAgICAgICAgICAgICAgdmFsdWVfMy5zdG9yZS51bnN1YnNjcmliZSh2YWx1ZV8zLnN0YXRlKTtcbiAgICAgICAgICAgICAgICB2YWx1ZV8zLnN0b3JlLmRlYWN0aXZhdGUoKTsgLy8gdGhpcyB3aWxsIGRlc3Ryb3kgdGhlIGV4dGVuc2lvbnNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgdmFyIHN0YXRlID0gdmFsdWVfMy5zdGF0ZS5zZWxmKCk7XG4gICAgICAgIC8vIGV4cG9zZSBwcm9wZXJ0eSBpbiBkZXZlbG9wbWVudCB0b29sc1xuICAgICAgICB2YWx1ZV8zWydbaG9va3N0YXRlKGxvY2FsKV0nXSA9IHN0YXRlOyAvLyBUT0RPIHVzZSBsYWJlbCBoZXJlLCBhZGQgY29yZSBleHRlbnNpb24gdG8gbGFiZWwgc3RhdGVzXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBTdGF0ZUZyYWdtZW50KHByb3BzKSB7XG4gICAgdmFyIHNjb3BlZCA9IHVzZUhvb2tzdGF0ZShwcm9wcy5zdGF0ZSwgcHJvcHMuZXh0ZW5zaW9uKTtcbiAgICByZXR1cm4gcHJvcHMuc3VzcGVuZCAmJiBzdXNwZW5kKHNjb3BlZCkgfHwgcHJvcHMuY2hpbGRyZW4oc2NvcGVkKTtcbn1cbi8qKlxuICogSWYgc3RhdGUgaXMgcHJvbWlzZWQsIHRoZW4gaXQgcmV0dXJucyBhIGNvbXBvbmVudCB3aGljaCBpbnRlZ3JhdGVzIHdpdGggUmVhY3QgMTggU3VzcGVuZCBmZWF0dXJlIGF1dG9tYXRpY2FsbHkuXG4gKiBOb3RlLCB0aGF0IFJlYWN0IDE4IFN1c3BlbmQgc3VwcG9ydCBmb3IgZGF0YSBsb2FkaW5nIGlzIHN0aWxsIGV4cGVyaW1lbnRhbCxcbiAqIGJ1dCBpdCB3b3JrZWQgYXMgcGVyIG91ciBleHBlcmltZW50cyBhbmQgdGVzdGluZy5cbiAqL1xuZnVuY3Rpb24gc3VzcGVuZChzdGF0ZSkge1xuICAgIHZhciBwID0gc3RhdGUucHJvbWlzZTtcbiAgICByZXR1cm4gcCAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LmxhenkoZnVuY3Rpb24gKCkgeyByZXR1cm4gcDsgfSkpO1xufVxuLy8vXG4vLy8gSU5URVJOQUwgU1lNQk9MUyAoTElCUkFSWSBJTVBMRU1FTlRBVElPTilcbi8vL1xudmFyIHNlbGYgPSBTeW1ib2woJ3NlbGYnKTtcbnZhciBFcnJvcklkO1xuKGZ1bmN0aW9uIChFcnJvcklkKSB7XG4gICAgRXJyb3JJZFtFcnJvcklkW1wiU3RhdGVVc2VkSW5EZXBlbmRlbmN5TGlzdFwiXSA9IDEwMF0gPSBcIlN0YXRlVXNlZEluRGVwZW5kZW5jeUxpc3RcIjtcbiAgICBFcnJvcklkW0Vycm9ySWRbXCJJbml0U3RhdGVUb1ZhbHVlRnJvbVN0YXRlXCJdID0gMTAxXSA9IFwiSW5pdFN0YXRlVG9WYWx1ZUZyb21TdGF0ZVwiO1xuICAgIEVycm9ySWRbRXJyb3JJZFtcIlNldFN0YXRlVG9WYWx1ZUZyb21TdGF0ZVwiXSA9IDEwMl0gPSBcIlNldFN0YXRlVG9WYWx1ZUZyb21TdGF0ZVwiO1xuICAgIEVycm9ySWRbRXJyb3JJZFtcIkdldFN0YXRlV2hlblByb21pc2VkXCJdID0gMTAzXSA9IFwiR2V0U3RhdGVXaGVuUHJvbWlzZWRcIjtcbiAgICBFcnJvcklkW0Vycm9ySWRbXCJTZXRTdGF0ZVdoZW5Qcm9taXNlZFwiXSA9IDEwNF0gPSBcIlNldFN0YXRlV2hlblByb21pc2VkXCI7XG4gICAgRXJyb3JJZFtFcnJvcklkW1wiU2V0U3RhdGVOZXN0ZWRUb1Byb21pc2VkXCJdID0gMTA1XSA9IFwiU2V0U3RhdGVOZXN0ZWRUb1Byb21pc2VkXCI7XG4gICAgRXJyb3JJZFtFcnJvcklkW1wiU2V0U3RhdGVXaGVuRGVzdHJveWVkXCJdID0gMTA2XSA9IFwiU2V0U3RhdGVXaGVuRGVzdHJveWVkXCI7XG4gICAgRXJyb3JJZFtFcnJvcklkW1wiVG9Kc29uX1ZhbHVlXCJdID0gMTA4XSA9IFwiVG9Kc29uX1ZhbHVlXCI7XG4gICAgRXJyb3JJZFtFcnJvcklkW1wiVG9Kc29uX1N0YXRlXCJdID0gMTA5XSA9IFwiVG9Kc29uX1N0YXRlXCI7XG4gICAgRXJyb3JJZFtFcnJvcklkW1wiR2V0UHJvcGVydHlfRnVuY3Rpb25cIl0gPSAxMTBdID0gXCJHZXRQcm9wZXJ0eV9GdW5jdGlvblwiO1xuICAgIEVycm9ySWRbRXJyb3JJZFtcIkluaXRTdGF0ZVN0b3JlU3dpdGNob3ZlclwiXSA9IDExMV0gPSBcIkluaXRTdGF0ZVN0b3JlU3dpdGNob3ZlclwiO1xuICAgIEVycm9ySWRbRXJyb3JJZFtcIkdldFVua25vd25QbHVnaW5cIl0gPSAxMjBdID0gXCJHZXRVbmtub3duUGx1Z2luXCI7XG4gICAgRXJyb3JJZFtFcnJvcklkW1wiU2V0UHJvcGVydHlfU3RhdGVcIl0gPSAyMDFdID0gXCJTZXRQcm9wZXJ0eV9TdGF0ZVwiO1xuICAgIEVycm9ySWRbRXJyb3JJZFtcIlNldFByb3BlcnR5X1ZhbHVlXCJdID0gMjAyXSA9IFwiU2V0UHJvcGVydHlfVmFsdWVcIjtcbiAgICBFcnJvcklkW0Vycm9ySWRbXCJTZXRQcm90b3R5cGVPZl9TdGF0ZVwiXSA9IDIwM10gPSBcIlNldFByb3RvdHlwZU9mX1N0YXRlXCI7XG4gICAgRXJyb3JJZFtFcnJvcklkW1wiU2V0UHJvdG90eXBlT2ZfVmFsdWVcIl0gPSAyMDRdID0gXCJTZXRQcm90b3R5cGVPZl9WYWx1ZVwiO1xuICAgIEVycm9ySWRbRXJyb3JJZFtcIlByZXZlbnRFeHRlbnNpb25zX1N0YXRlXCJdID0gMjA1XSA9IFwiUHJldmVudEV4dGVuc2lvbnNfU3RhdGVcIjtcbiAgICBFcnJvcklkW0Vycm9ySWRbXCJQcmV2ZW50RXh0ZW5zaW9uc19WYWx1ZVwiXSA9IDIwNl0gPSBcIlByZXZlbnRFeHRlbnNpb25zX1ZhbHVlXCI7XG4gICAgRXJyb3JJZFtFcnJvcklkW1wiRGVmaW5lUHJvcGVydHlfU3RhdGVcIl0gPSAyMDddID0gXCJEZWZpbmVQcm9wZXJ0eV9TdGF0ZVwiO1xuICAgIEVycm9ySWRbRXJyb3JJZFtcIkRlZmluZVByb3BlcnR5X1ZhbHVlXCJdID0gMjA4XSA9IFwiRGVmaW5lUHJvcGVydHlfVmFsdWVcIjtcbiAgICBFcnJvcklkW0Vycm9ySWRbXCJEZWxldGVQcm9wZXJ0eV9TdGF0ZVwiXSA9IDIwOV0gPSBcIkRlbGV0ZVByb3BlcnR5X1N0YXRlXCI7XG4gICAgRXJyb3JJZFtFcnJvcklkW1wiRGVsZXRlUHJvcGVydHlfVmFsdWVcIl0gPSAyMTBdID0gXCJEZWxldGVQcm9wZXJ0eV9WYWx1ZVwiO1xuICAgIEVycm9ySWRbRXJyb3JJZFtcIkNvbnN0cnVjdF9TdGF0ZVwiXSA9IDIxMV0gPSBcIkNvbnN0cnVjdF9TdGF0ZVwiO1xuICAgIEVycm9ySWRbRXJyb3JJZFtcIkNvbnN0cnVjdF9WYWx1ZVwiXSA9IDIxMl0gPSBcIkNvbnN0cnVjdF9WYWx1ZVwiO1xuICAgIEVycm9ySWRbRXJyb3JJZFtcIkFwcGx5X1N0YXRlXCJdID0gMjEzXSA9IFwiQXBwbHlfU3RhdGVcIjtcbiAgICBFcnJvcklkW0Vycm9ySWRbXCJBcHBseV9WYWx1ZVwiXSA9IDIxNF0gPSBcIkFwcGx5X1ZhbHVlXCI7XG59KShFcnJvcklkIHx8IChFcnJvcklkID0ge30pKTtcbnZhciBTdGF0ZUludmFsaWRVc2FnZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdGF0ZUludmFsaWRVc2FnZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0YXRlSW52YWxpZFVzYWdlRXJyb3IocGF0aCwgaWQsIGRldGFpbHMpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwiRXJyb3I6IEhPT0tTVEFURS1cIi5jb25jYXQoaWQsIFwiIFtwYXRoOiAvXCIpLmNvbmNhdChwYXRoLmpvaW4oJy8nKSkuY29uY2F0KGRldGFpbHMgPyBcIiwgZGV0YWlsczogXCIuY29uY2F0KGRldGFpbHMpIDogJycsIFwiXS4gXCIpICtcbiAgICAgICAgICAgIFwiU2VlIGh0dHBzOi8vaG9va3N0YXRlLmpzLm9yZy9kb2NzL2V4Y2VwdGlvbnMjaG9va3N0YXRlLVwiLmNvbmNhdChpZCkpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBTdGF0ZUludmFsaWRVc2FnZUVycm9yO1xufShFcnJvcikpO1xudmFyIFNlbGZNZXRob2RzSUQgPSBTeW1ib2woJ1Byb3h5TWFya2VyJyk7XG52YXIgUm9vdFBhdGggPSBbXTtcbnZhciBTdG9yZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdG9yZShfdmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XG4gICAgICAgIC8vID4gMCBtZWFucyBhY3RpdmUgc3RvcmUsIDwgMCBtZWFucyBkZXN0cm95ZWRcbiAgICAgICAgLy8gcGxlYXNlIG5vdGUsIGluIHJlYWN0IHN0cmljdCBtb2RlIGFuZCBob3QgcmVsb2FkIGNhc2VzXG4gICAgICAgIC8vIHN0YXRlIGNhbiBiZSByZXVzZWQsIHNvIHdlIHNob3VsZCBzdXBwb3J0IHN0b3JlIHJlc3VyZWN0aW9uXG4gICAgICAgIHRoaXMuZWRpdGlvbiA9IDE7XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZXJzID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAoT2JqZWN0KF92YWx1ZSkgPT09IF92YWx1ZSAmJlxuICAgICAgICAgICAgY29uZmlndXJhdGlvbi5wcm9taXNlRGV0ZWN0b3IoX3ZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRQcm9taXNlZChfdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF92YWx1ZSA9PT0gbm9uZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRQcm9taXNlZCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvblNldFVzZWRTdG9yZVN0YXRlTWV0aG9kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9zdGF0ZU1ldGhvZHMucmVjb25zdHJ1Y3QoUm9vdFBhdGgsIF90aGlzLmdldChSb290UGF0aCksIF90aGlzLmVkaXRpb24sIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgb25TZXRVc2VkU3RvcmVTdGF0ZU1ldGhvZHNbSXNVbm1vdW50ZWRdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc3RhdGVNZXRob2RzID0gbmV3IFN0YXRlTWV0aG9kc0ltcGwodGhpcywgUm9vdFBhdGgsIHRoaXMuZ2V0KFJvb3RQYXRoKSwgdGhpcy5lZGl0aW9uLCBvblNldFVzZWRTdG9yZVN0YXRlTWV0aG9kcyk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlKHRoaXMuX3N0YXRlTWV0aG9kcyk7XG4gICAgfVxuICAgIFN0b3JlLnByb3RvdHlwZS5zZXRQcm9taXNlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbm9uZTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZUVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9wcm9taXNlUmVzb2x2ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghcHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Byb21pc2VSZXNvbHZlciA9IHJlc29sdmU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm9taXNlID0gcHJvbWlzZVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fcHJvbWlzZSA9PT0gcHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9wcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIF90aGlzLl9wcm9taXNlRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Byb21pc2VSZXNvbHZlciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZShfdGhpcy5fc3RhdGVNZXRob2RzLnNlbGYoKSwgX3RoaXMuc2V0KFJvb3RQYXRoLCByKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKF90aGlzLl9wcm9taXNlID09PSBwcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Byb21pc2VSZXNvbHZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcHJvbWlzZUVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIF90aGlzLmVkaXRpb24gKz0gMTtcbiAgICAgICAgICAgICAgICB2YXIgYWQgPSB7IHBhdGg6IFJvb3RQYXRoIH07XG4gICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlKF90aGlzLl9zdGF0ZU1ldGhvZHMuc2VsZigpLCBhZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wcm9taXNlID0gcHJvbWlzZTtcbiAgICB9O1xuICAgIFN0b3JlLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uIChleHRlbnNpb25GYWN0b3J5KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgaWYgKHRoaXMuZWRpdGlvbiA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdGlvbiA9IC10aGlzLmVkaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2V4dGVuc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9leHRlbnNpb24gPSBleHRlbnNpb25GYWN0b3J5ID09PSBudWxsIHx8IGV4dGVuc2lvbkZhY3RvcnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4dGVuc2lvbkZhY3RvcnkoKTtcbiAgICAgICAgICAgIHRoaXMuX2V4dGVuc2lvbk1ldGhvZHMgPSAoX2IgPSAoX2EgPSB0aGlzLl9leHRlbnNpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vbkNyZWF0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRoaXMuX3N0YXRlTWV0aG9kcy5zZWxmKCksIHt9KTtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgaW52b2tlZCB3aXRoIGFsbCBleHRlbnNpb24gbWV0aG9kcyBhY3RpdmF0ZWQgb24gdGhlIHN0YXRlXG4gICAgICAgICAgICAoX2QgPSAoX2MgPSB0aGlzLl9leHRlbnNpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5vbkluaXQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jLCB0aGlzLl9zdGF0ZU1ldGhvZHMuc2VsZigpLCB0aGlzLl9leHRlbnNpb25NZXRob2RzIHx8IHt9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RvcmUucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLl9leHRlbnNpb24pIHtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMuX2V4dGVuc2lvbikub25EZXN0cm95KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGhpcy5fc3RhdGVNZXRob2RzLnNlbGYoKSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZXh0ZW5zaW9uO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V4dGVuc2lvbk1ldGhvZHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWRpdGlvbiA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdGlvbiA9IC10aGlzLmVkaXRpb247XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdG9yZS5wcm90b3R5cGUsIFwiZXh0ZW5zaW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXh0ZW5zaW9uTWV0aG9kcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdG9yZS5wcm90b3R5cGUsIFwicHJvbWlzZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RvcmUucHJvdG90eXBlLCBcInByb21pc2VFcnJvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2VFcnJvcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFN0b3JlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fdmFsdWU7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG5vbmUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aC5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRbcF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgU3RvcmUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChwYXRoLCB2YWx1ZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIFJvb3QgdmFsdWUgVVBEQVRFIGNhc2UsXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG5vbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFByb21pc2VkKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChPYmplY3QodmFsdWUpID09PSB2YWx1ZSAmJiBjb25maWd1cmF0aW9uLnByb21pc2VEZXRlY3Rvcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFByb21pc2VkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5vbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wcm9taXNlICYmICF0aGlzLl9wcm9taXNlUmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3RhdGVJbnZhbGlkVXNhZ2VFcnJvcihwYXRoLCBFcnJvcklkLlNldFN0YXRlV2hlblByb21pc2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2VFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2VmFsdWUgPSB0aGlzLl92YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmFmdGVyU2V0KCk7XG4gICAgICAgICAgICBpZiAocHJldlZhbHVlID09PSBub25lICYmIHRoaXMuX3ZhbHVlICE9PSBub25lICYmIHRoaXMuX3Byb21pc2VSZXNvbHZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZUVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHZhciByZXNvbHZlciA9IHRoaXMuX3Byb21pc2VSZXNvbHZlcjtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlUmVzb2x2ZXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZXNvbHZlcih0aGlzLl92YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdCh2YWx1ZSkgPT09IHZhbHVlICYmIGNvbmZpZ3VyYXRpb24ucHJvbWlzZURldGVjdG9yKHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gVE9ETyB0aGlzIG9uZSBzdGlsbCBjYW4gZ2V0IGludG8gdGhlIHN0YXRlIGFzIG5lc3RlZCBwcm9wZXJ0eSwgbmVlZCB0byBjaGVjayBvbiByZWFkIGluc3RlYWRcbiAgICAgICAgICAgIHRocm93IG5ldyBTdGF0ZUludmFsaWRVc2FnZUVycm9yKHBhdGgsIEVycm9ySWQuU2V0U3RhdGVOZXN0ZWRUb1Byb21pc2VkKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdmFsdWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldFtwYXRoW2ldXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHAgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG5vbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBQcm9wZXJ0eSBVUERBVEUgY2FzZVxuICAgICAgICAgICAgICAgIHRhcmdldFtwXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuYWZ0ZXJTZXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFByb3BlcnR5IERFTEVURSBjYXNlXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiB0eXBlb2YgcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnNwbGljZShwLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRbcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYWZ0ZXJTZXQoKTtcbiAgICAgICAgICAgICAgICAvLyBpZiBhbiBhcnJheSBvZiBvYmplY3RzIGlzIGFib3V0IHRvIGxvb3NlIGV4aXN0aW5nIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gd2UgY29uc2lkZXIgaXQgaXMgdGhlIHdob2xlIG9iamVjdCBpcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgaWRlbnRpZmllZCBieSB1cHBlciBwYXRoXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogcGF0aC5zbGljZSgwLCAtMSksXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IChfYSA9IHt9LCBfYVtwXSA9IFwiRFwiLCBfYSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbm9uZSkge1xuICAgICAgICAgICAgLy8gUHJvcGVydHkgSU5TRVJUIGNhc2VcbiAgICAgICAgICAgIHRhcmdldFtwXSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5hZnRlclNldCgpO1xuICAgICAgICAgICAgLy8gaWYgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpcyBhYm91dCB0byBiZSBleHRlbmRlZCBieSBuZXcgcHJvcGVydHlcbiAgICAgICAgICAgIC8vIHdlIGNvbnNpZGVyIGl0IGlzIHRoZSB3aG9sZSBvYmplY3QgaXMgY2hhbmdlZFxuICAgICAgICAgICAgLy8gd2hpY2ggaXMgaWRlbnRpZmllZCBieSB1cHBlciBwYXRoXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGguc2xpY2UoMCwgLTEpLFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IChfYiA9IHt9LCBfYltwXSA9IFwiSVwiLCBfYilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9uLWV4aXN0aW5nIHByb3BlcnR5IERFTEVURSBjYXNlXG4gICAgICAgIC8vIG5vLW9wXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXRoOiBwYXRoXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBTdG9yZS5wcm90b3R5cGUucHJlc2V0ID0gZnVuY3Rpb24gKHN0YXRlLCB2YWx1ZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLl9leHRlbnNpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vblByZXNldCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHN0YXRlLCB2YWx1ZSwgdGhpcy5fc3RhdGVNZXRob2RzLnNlbGYoKSk7XG4gICAgfTtcbiAgICBTdG9yZS5wcm90b3R5cGUucHJlbWVyZ2UgPSBmdW5jdGlvbiAoc3RhdGUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuX2V4dGVuc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uUHJlbWVyZ2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBzdGF0ZSwgdmFsdWUsIHRoaXMuX3N0YXRlTWV0aG9kcy5zZWxmKCkpO1xuICAgIH07XG4gICAgU3RvcmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgYWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5fZXh0ZW5zaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25TZXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBzdGF0ZSwgYWQsIHRoaXMuX3N0YXRlTWV0aG9kcy5zZWxmKCkpO1xuICAgICAgICB2YXIgYWN0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLy8gY2hlY2sgaWYgYWN0aW9ucyBkZXNjcmlwdG9yIGNhbiBiZSB1bmZvbGRlZCBpbnRvIGEgbnVtYmVyIG9mIGluZGl2aWR1YWwgdXBkYXRlIGFjdGlvbnNcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgY2FzZSB3aGVuIG1lcmdlIGNhbGwgc3dhcHMgdG8gcHJvcGVydGllcyBmb3IgZXhhbXBsZVxuICAgICAgICAvLyBzbyB3ZSBvcHRpbWl6ZSByZXJlbmRlcmluZyBvbmx5IHRoZXNlIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKGFkLmFjdGlvbnMgJiYgT2JqZWN0LnZhbHVlcyhhZC5hY3Rpb25zKS5maW5kSW5kZXgoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkgIT09IFwiVVwiOyB9KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGFsbCBhY3Rpb25zIGFyZSB1cGRhdGUgYWN0aW9uc1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoYWQuYWN0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3N1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMub25TZXQoeyBwYXRoOiBhZC5wYXRoLmNvbmNhdChrZXkpIH0sIGFjdGlvbnMpOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAocykgeyByZXR1cm4gcy5vblNldChhZCwgYWN0aW9ucyk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSgpOyB9KTtcbiAgICB9O1xuICAgIFN0b3JlLnByb3RvdHlwZS5hZnRlclNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWRpdGlvbiA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdGlvbiArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVkaXRpb24gPCAwKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRpb24gLT0gMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RvcmUucHJvdG90eXBlLnRvTWV0aG9kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlTWV0aG9kcztcbiAgICB9O1xuICAgIFN0b3JlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAobCkge1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmVycy5hZGQobCk7XG4gICAgfTtcbiAgICBTdG9yZS5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAobCkge1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmVycy5kZWxldGUobCk7XG4gICAgfTtcbiAgICBTdG9yZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgU3RhdGVJbnZhbGlkVXNhZ2VFcnJvcihSb290UGF0aCwgRXJyb3JJZC5Ub0pzb25fVmFsdWUpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0b3JlO1xufSgpKTtcbi8vIHVzZSBzeW1ib2wgcHJvcGVydHkgdG8gYWxsb3cgZm9yIGVhc2llciByZWZlcmVuY2UgZmluZGluZ1xudmFyIFVudXNlZFZhbHVlID0gU3ltYm9sKCdVbnVzZWRWYWx1ZScpO1xuLy8gdXNlIHN5bWJvbCB0byBtYXJrIHRoYXQgYSBmdW5jdGlvbiBoYXMgbm8gZWZmZWN0IGFueW1vcmVcbnZhciBJc1VubW91bnRlZCA9IFN5bWJvbCgnSXNVbm1vdW50ZWQnKTtcbnZhciBTdGF0ZU1ldGhvZHNJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRlTWV0aG9kc0ltcGwoc3RvcmUsIHBhdGgsIHZhbHVlU291cmNlLCB2YWx1ZUVkaXRpb24sIG9uU2V0VXNlZCkge1xuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMudmFsdWVTb3VyY2UgPSB2YWx1ZVNvdXJjZTtcbiAgICAgICAgdGhpcy52YWx1ZUVkaXRpb24gPSB2YWx1ZUVkaXRpb247XG4gICAgICAgIHRoaXMub25TZXRVc2VkID0gb25TZXRVc2VkO1xuICAgICAgICB0aGlzLnZhbHVlVXNlZCA9IFVudXNlZFZhbHVlO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhdGVNZXRob2RzSW1wbC5wcm90b3R5cGUsIF9fc3RhdGUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuZ2V0KCksIHRoaXMuc2VsZigpXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFN0YXRlTWV0aG9kc0ltcGwucHJvdG90eXBlLnJlY29uc3RydWN0ID0gZnVuY3Rpb24gKHBhdGgsIHZhbHVlU291cmNlLCB2YWx1ZUVkaXRpb24sIHJlc2V0KSB7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMudmFsdWVTb3VyY2UgPSB2YWx1ZVNvdXJjZTtcbiAgICAgICAgdGhpcy52YWx1ZUVkaXRpb24gPSB2YWx1ZUVkaXRpb247XG4gICAgICAgIHRoaXMudmFsdWVVc2VkID0gVW51c2VkVmFsdWU7XG4gICAgICAgIGlmIChyZXNldCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2VsZlVzZWQ7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jaGlsZHJlbkNyZWF0ZWQ7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jaGlsZHJlblVzZWRQcmV2aW91cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVVc2VkTm9Qcm94eVByZXZpb3VzID0gdGhpcy52YWx1ZVVzZWROb1Byb3h5O1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlblVzZWRQcmV2aW91cyA9IHRoaXMuY2hpbGRyZW5Vc2VkO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLnZhbHVlVXNlZE5vUHJveHk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNoaWxkcmVuVXNlZDtcbiAgICAgICAgLy8gV2Ugc2hvdWxkIG5vdCBkZWxldGUgc3Vic2NyaWJlcnMgYXMgdGhlc2UgYXJlIHNlbGYgY2xlYW5lZCB1cCB3aGVuIHVubW91bnRlZFxuICAgICAgICAvLyBUaGVvcmV0aWNhbGx5IGl0IGlzIHBvc3NpYmxlIHRvIHJlY29ubmVjdCBzdWJzY3JpYmVycyBsaWtlIHdlIGRvbmUgaXQgZm9yIFxuICAgICAgICAvLyBjaGlsZHJlbiwgYnV0IGl0IGlzIGVhc2llciBhbmQgbW9yZSBlZmZpY2llbnQgdG8gbGVhdmUgc3Vic2NyaWJlcnMgdG8gaGF2ZSBpbmRlcGVuZGVudCBsaWZlY3ljbGVcbiAgICAgICAgLy8gSWYgd2UgZGVsZXRlIHN1YnNjcmliZXJzIGhlcmUsIHNjb3BlZCBzdGF0ZXMgd3JhcHBlZCBpbiBSZWFjdC5tZW1vXG4gICAgICAgIC8vIHdpbGwgbG9zZSBzdGF0ZSBjaGFuZ2UgcHJvcGFnYXRpb24gYW5kIHJlcmVuZGVyaW5nIGZvciBzY29wcGVkIHN0YXRlc1xuICAgICAgICAvLyBkZWxldGUgdGhpcy5zdWJzY3JpYmVycztcbiAgICB9O1xuICAgIFN0YXRlTWV0aG9kc0ltcGwucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gTWFyayBpdCdzIGFzIHVzZWQsIGJlY2F1c2UgaXQgaXMgdXNlZCBpbiBhIGRlcGVuZGVuY3kgbGlzdFxuICAgICAgICAvLyAod2UgYXJlIG1ha2luZyBpdCdzIHZhbHVlIHVzZWQgaW1wbGljaXRseSwgc28gcmVyZW5kZXIgaXMgdHJpZ2dlcmVkKS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBubyByZXJlbmRlciA9PiBubyBlZmZlY3RzIHJ1bm5pbmcsIGV2ZW4gd2hlbiBhIHZhbHVlIGlzIGNoYW5nZWQuXG4gICAgICAgIC8vIFRoaXMgaXMgbWFya2luZyB0aGUgc3RhdGUgdXNlZCBhIGJpdCBtb3JlIHRoYW4gaXQgbWlnaHQgYmUgcmVhbGx5IHVzZWRcbiAgICAgICAgLy8gaW4gdGhlIGVmZmVjdCBjYWxsYmFjay4gTW9yZSBvcHRpbWl6ZWQgLyBwcmVjaXNlIGltcGxlbWVudGF0aW9uIHdvdWxkIGJlXG4gICAgICAgIC8vIHRvIHJlbWVtYmVyIHVzZVNlbGYgYXMgcHJldmlvdXMgKHNpbWlsYXIgdG8gY2hpbGRyZW5Vc2VkKSxcbiAgICAgICAgLy8gYnV0IGl0IGlzIGEgbG90IG1vcmUgY29tcGxpY2F0ZWQgYW5kIHRoZSBiZW5lZml0IGlzIG5vdCB3b3J0aCB0aGUgY29tcGxleGl0eS5cbiAgICAgICAgLy8gU28sIG1hcmsgaXQgdXNlZC5cbiAgICAgICAgLy8gV2UgYWxzbyB1c2luZyBpdCB3aXRob3V0IHByb3h5IGlmIGl0IHdhc3MgdXNlZCB3aXRob3V0IHByb3h5IGR1cmluZyB0aGVcbiAgICAgICAgLy8gcHJldmlvdXMgcmVuZGVyLCBiZWNhdXNlIG90aGVyd2lzZSBjaGlsZHJlbiB1c2FnZSBtaWdodCBiZSBub3QgdHJhY2VkIGNvbXBsZXRlbHlcbiAgICAgICAgLy8gYW5kIHNvIHdpbGwgbm90IHJlc3VsdCBpbiByZW5yZWRlciBpZiBjaGlsZHJlbiBhcmUgdXBkYXRlZC5cbiAgICAgICAgLy8gVGhpcyBpcyBjb3ZlcmVkIGJ5IHNvbWUgdGVzdHMsIGJ1dCB0aGVyZSBhcmUgc28gbWFueSBwb3NzaWJsZSBjb3JuZXIgY2FzZXMuLi5cbiAgICAgICAgdGhpcy5nZXQoeyBfX2ludGVybmFsQWxsb3dQcm9taXNlZDogdHJ1ZSwgbm9wcm94eTogdGhpcy52YWx1ZVVzZWROb1Byb3h5UHJldmlvdXMgfSk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5Vc2VkID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMuY2hpbGRyZW5Vc2VkUHJldmlvdXMpLCB0aGlzLmNoaWxkcmVuVXNlZCk7XG4gICAgfTtcbiAgICBTdGF0ZU1ldGhvZHNJbXBsLnByb3RvdHlwZS5nZXRVbnRyYWNrZWQgPSBmdW5jdGlvbiAoX19pbnRlcm5hbEFsbG93UHJvbWlzZWQpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVFZGl0aW9uICE9PSB0aGlzLnN0b3JlLmVkaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVTb3VyY2UgPSB0aGlzLnN0b3JlLmdldCh0aGlzLnBhdGgpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUVkaXRpb24gPSB0aGlzLnN0b3JlLmVkaXRpb247XG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZVVzZWQgIT09IFVudXNlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZVVzZWQgPSBVbnVzZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmdldCh7IF9faW50ZXJuYWxBbGxvd1Byb21pc2VkOiB0cnVlIH0pOyAvLyByZW5ldyBjYWNoZSB0byBrZWVwIGl0IG1hcmtlZCB1c2VkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9faW50ZXJuYWxBbGxvd1Byb21pc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdG9yZS5wcm9taXNlRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuc3RvcmUucHJvbWlzZUVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0b3JlLnByb21pc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTdGF0ZUludmFsaWRVc2FnZUVycm9yKHRoaXMucGF0aCwgRXJyb3JJZC5HZXRTdGF0ZVdoZW5Qcm9taXNlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVTb3VyY2U7XG4gICAgfTtcbiAgICBTdGF0ZU1ldGhvZHNJbXBsLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciB2YWx1ZVNvdXJjZSA9IHRoaXMuZ2V0VW50cmFja2VkKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5fX2ludGVybmFsQWxsb3dQcm9taXNlZCk7XG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3RlYWx0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlU291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZhbHVlVXNlZCA9PT0gVW51c2VkVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlU291cmNlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVVc2VkID0gdGhpcy52YWx1ZUFycmF5SW1wbCh2YWx1ZVNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChPYmplY3QodmFsdWVTb3VyY2UpID09PSB2YWx1ZVNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gdmFsdWVTb3VyY2UuY29uc3RydWN0b3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lKSA9PT0gXCJPYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlVXNlZCA9IHRoaXMudmFsdWVPYmplY3RJbXBsKHZhbHVlU291cmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFueSBvdGhlciBvYmplY3QgZXhjZXB0IE9iamVjdCwgZm9yIGV4YW1wbGUgRGF0ZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlVXNlZE5vUHJveHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlVXNlZCA9IHZhbHVlU291cmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVVc2VkID0gdmFsdWVTb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ub3Byb3h5KSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlVXNlZE5vUHJveHkgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlU291cmNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlVXNlZDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZU1ldGhvZHNJbXBsLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gdmFyaW91cyB0b29scywgaW5jbHVkaW5nIHJlYWN0IGRldiB0b29scyBhbmQgd2VicGFjayBpbXBvcnRcbiAgICAgICAgICAgIC8vIGluc3BlY3QgYW4gb2JqZWN0IGFuZCBpdCdzIHByb3BlcnRpZXNcbiAgICAgICAgICAgIC8vIHNvIHRoZXNlIHNob3VsZCBub3QgdGhyb3dcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGlzLmdldCh7IF9faW50ZXJuYWxBbGxvd1Byb21pc2VkOiB0cnVlIH0pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFN0YXRlTWV0aG9kc0ltcGwucHJvdG90eXBlLnNldFVudHJhY2tlZFY0ID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3VmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUodGhpcy5nZXRVbnRyYWNrZWQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9yZS5wcmVzZXQodGhpcy5zZWxmKCksIG5ld1ZhbHVlKTtcbiAgICAgICAgaWYgKE9iamVjdChuZXdWYWx1ZSkgPT09IG5ld1ZhbHVlICYmIG5ld1ZhbHVlW1NlbGZNZXRob2RzSURdKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGNoZWNrIG9uIHJlYWQgaW5zdGVhZCBhcyBpdCBtaWdodCBlc2NhcGUgYXMgbmVzdGVkIG9uIHNldCBhbnl3YXlcbiAgICAgICAgICAgIHRocm93IG5ldyBTdGF0ZUludmFsaWRVc2FnZUVycm9yKHRoaXMucGF0aCwgRXJyb3JJZC5TZXRTdGF0ZVRvVmFsdWVGcm9tU3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gT2JqZWN0KG5ld1ZhbHVlKSAmJiBuZXdWYWx1ZSA9PT0gdGhpcy5nZXRVbnRyYWNrZWQodHJ1ZSkpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgcHJpbWl0aXZlIHZhbHVlIGFuZCBoYXMgbm90IGNoYW5nZWRcbiAgICAgICAgICAgIC8vIHNvIHNraXAgdGhpcyBzZXQgY2FsbCBhcyBpdCBkb2VzIG5vdCBtYWtlIGFuIGVmZmVjdFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuc2V0KHRoaXMucGF0aCwgbmV3VmFsdWUpO1xuICAgIH07XG4gICAgU3RhdGVNZXRob2RzSW1wbC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgIHZhciBhZCA9IHRoaXMuc2V0VW50cmFja2VkVjQobmV3VmFsdWUpO1xuICAgICAgICBpZiAoYWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUudXBkYXRlKHRoaXMuc2VsZigpLCBhZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0YXRlTWV0aG9kc0ltcGwucHJvdG90eXBlLm1lcmdlVW50cmFja2VkID0gZnVuY3Rpb24gKHNvdXJjZVZhbHVlKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5tZXJnZVVudHJhY2tlZFY0KHNvdXJjZVZhbHVlKTtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgIHJldHVybiBbci5wYXRoXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBTdGF0ZU1ldGhvZHNJbXBsLnByb3RvdHlwZS5tZXJnZVVudHJhY2tlZFY0ID0gZnVuY3Rpb24gKHNvdXJjZVZhbHVlKSB7XG4gICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSB0aGlzLmdldFVudHJhY2tlZCgpO1xuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzb3VyY2VWYWx1ZSA9IHNvdXJjZVZhbHVlKGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9yZS5wcmVtZXJnZSh0aGlzLnNlbGYoKSwgc291cmNlVmFsdWUpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2VWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWRfMSA9IHsgcGF0aDogdGhpcy5wYXRoLCBhY3Rpb25zOiB7fSB9O1xuICAgICAgICAgICAgICAgIHNvdXJjZVZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRfMS5hY3Rpb25zW2N1cnJlbnRWYWx1ZS5wdXNoKGUpIC0gMV0gPSBcIklcIjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoYWRfMS5hY3Rpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VW50cmFja2VkVjQoY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkXzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGFkXzIgPSB7IHBhdGg6IHRoaXMucGF0aCwgYWN0aW9uczoge30gfTtcbiAgICAgICAgICAgICAgICB2YXIgZGVsZXRlZEluZGV4ZXNfMSA9IFtdO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZVZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBOdW1iZXIoaSk7IH0pXG4gICAgICAgICAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC0gYjsgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gTnVtYmVyKGkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3UHJvcFZhbHVlID0gc291cmNlVmFsdWVbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3UHJvcFZhbHVlID09PSBub25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZF8yLmFjdGlvbnNbaW5kZXhdID0gXCJEXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVkSW5kZXhlc18xLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IGluIGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkXzIuYWN0aW9uc1tpbmRleF0gPSBcIlVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkXzIuYWN0aW9uc1tpbmRleF0gPSBcIklcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZVtpbmRleF0gPSBuZXdQcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBpbmRleGVzIGFyZSBhc2NlbmRpbmcgc29ydGVkIGFzIHBlciBhYm92ZVxuICAgICAgICAgICAgICAgIC8vIHNvLCBkZWxldGUgb25lIGJ5IG9uZSBmcm9tIHRoZSBlbmRcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHdheSBpbmRleCBwb3NpdGlvbnMgZG8gbm90IGNoYW5nZVxuICAgICAgICAgICAgICAgIGRlbGV0ZWRJbmRleGVzXzEucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlLnNwbGljZShwLCAxKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoYWRfMi5hY3Rpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VW50cmFja2VkVjQoY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkXzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKE9iamVjdChjdXJyZW50VmFsdWUpID09PSBjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBhZF8zID0geyBwYXRoOiB0aGlzLnBhdGgsIGFjdGlvbnM6IHt9IH07XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2VWYWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1Byb3BWYWx1ZSA9IHNvdXJjZVZhbHVlW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKG5ld1Byb3BWYWx1ZSA9PT0gbm9uZSkge1xuICAgICAgICAgICAgICAgICAgICBhZF8zLmFjdGlvbnNba2V5XSA9IFwiRFwiO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY3VycmVudFZhbHVlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5IGluIGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRfMy5hY3Rpb25zW2tleV0gPSBcIlVcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkXzMuYWN0aW9uc1trZXldID0gXCJJXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlW2tleV0gPSBuZXdQcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoYWRfMy5hY3Rpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRVbnRyYWNrZWRWNChjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhZF8zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGN1cnJlbnRWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFVudHJhY2tlZFY0KChjdXJyZW50VmFsdWUgKyBTdHJpbmcoc291cmNlVmFsdWUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRVbnRyYWNrZWRWNChzb3VyY2VWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0YXRlTWV0aG9kc0ltcGwucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKHNvdXJjZVZhbHVlKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5tZXJnZVVudHJhY2tlZFY0KHNvdXJjZVZhbHVlKTtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUudXBkYXRlKHRoaXMuc2VsZigpLCByKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RhdGVNZXRob2RzSW1wbC5wcm90b3R5cGUubmVzdGVkID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZChrZXkpLnNlbGYoKTtcbiAgICB9O1xuICAgIFN0YXRlTWV0aG9kc0ltcGwucHJvdG90eXBlLnJlcmVuZGVyID0gZnVuY3Rpb24gKHBhdGhzKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgcGF0aHNfMSA9IHBhdGhzOyBfaSA8IHBhdGhzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IHBhdGhzXzFbX2ldO1xuICAgICAgICAgICAgdGhpcy5zdG9yZS51cGRhdGUodGhpcy5zZWxmKCksIHsgcGF0aDogcGF0aCB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RhdGVNZXRob2RzSW1wbC5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoZXh0ZW5zaW9uRmFjdG9yeSkge1xuICAgICAgICB0aGlzLnN0b3JlLmFjdGl2YXRlKGV4dGVuc2lvbkZhY3RvcnkpO1xuICAgIH07XG4gICAgU3RhdGVNZXRob2RzSW1wbC5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5kZWFjdGl2YXRlKCk7XG4gICAgfTtcbiAgICBTdGF0ZU1ldGhvZHNJbXBsLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAobCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpYmVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJzID0gbmV3IFNldCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlcnMuYWRkKGwpO1xuICAgIH07XG4gICAgU3RhdGVNZXRob2RzSW1wbC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAobCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpYmVycykge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVycy5kZWxldGUobCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZU1ldGhvZHNJbXBsLnByb3RvdHlwZSwgXCJpc01vdW50ZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5vblNldFVzZWRbSXNVbm1vdW50ZWRdO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU3RhdGVNZXRob2RzSW1wbC5wcm90b3R5cGUub25Nb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMub25TZXRVc2VkW0lzVW5tb3VudGVkXTtcbiAgICB9O1xuICAgIFN0YXRlTWV0aG9kc0ltcGwucHJvdG90eXBlLm9uVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vblNldFVzZWRbSXNVbm1vdW50ZWRdID0gdHJ1ZTtcbiAgICB9O1xuICAgIFN0YXRlTWV0aG9kc0ltcGwucHJvdG90eXBlLm9uU2V0ID0gZnVuY3Rpb24gKGFkLCBhY3Rpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgaXNBZmZlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKF90aGlzLnZhbHVlVXNlZE5vUHJveHlcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHRoaXMgY29uZGl0aW9uIGJlY29tZXMgcmVkdW5kYW50IHdoZW4gRG93bmdyYWRlZCBwbHVnaW5zIGlzIGRlbGV0ZWRcbiAgICAgICAgICAgICAgICAmJiBfdGhpcy52YWx1ZVVzZWQgIT09IFVudXNlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9ucy5hZGQoX3RoaXMub25TZXRVc2VkKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuc2VsZlVzZWQ7XG4gICAgICAgICAgICAgICAgaXNBZmZlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGF0aCA9IGFkLnBhdGg7XG4gICAgICAgICAgICB2YXIgbmV4dENoaWxkS2V5ID0gcGF0aFtfdGhpcy5wYXRoLmxlbmd0aF07XG4gICAgICAgICAgICBpZiAobmV4dENoaWxkS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZXh0IGNoaWxkIHRvIGRpdmUgaW50b1xuICAgICAgICAgICAgICAgIC8vIFNvIGl0IGlzIHRoaXMgb25lIHdoaWNoIHdhcyB1cGRhdGVkXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnZhbHVlVXNlZCAhPT0gVW51c2VkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9ucy5hZGQoX3RoaXMub25TZXRVc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLnNlbGZVc2VkO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuY2hpbGRyZW5Vc2VkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWQuYWN0aW9ucyAmJiBfdGhpcy5jaGlsZHJlbkNyZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gYWRkIGF1dG9tYXRlZCB1bml0IHRlc3RzIGZvciB0aGlzIHBhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KF90aGlzLnZhbHVlU291cmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIE9iamVjdC52YWx1ZXMoYWQuYWN0aW9ucykuaW5jbHVkZXMoXCJEXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhbiBhcnJheSBhbmQgc29tZSBlbGVtZW50cyB3ZXJlIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyBpbnZhbGlkYXRlIGNhY2hlIGZvciBhbGwgY2hpbGRyZW4gYWZ0ZXIgdGhlIGZpcnN0IGRlbGV0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3REZWxldGVkSW5kZXggPSBPYmplY3Qua2V5cyhhZC5hY3Rpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBOdW1iZXIoaSk7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC0gYjsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoZnVuY3Rpb24gKGkpIHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IGFkLmFjdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtpXSkgPT09IFwiRFwiOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjaGlsZEtleSBpbiBfdGhpcy5jaGlsZHJlbkNyZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE51bWJlcihjaGlsZEtleSkgPj0gZmlyc3REZWxldGVkSW5kZXggfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkS2V5IGluIGFkLmFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5jaGlsZHJlbkNyZWF0ZWRbY2hpbGRLZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY2hpbGRLZXkgaW4gYWQuYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuY2hpbGRyZW5DcmVhdGVkW2NoaWxkS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuY2hpbGRyZW5DcmVhdGVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0Q2hpbGQgPSAoX2EgPSBfdGhpcy5jaGlsZHJlblVzZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtuZXh0Q2hpbGRLZXldO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hpbGQgJiYgbmV4dENoaWxkLm9uU2V0KGFkLCBhY3Rpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuc2VsZlVzZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc0FmZmVjdGVkO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdXBkYXRlZCA9IHVwZGF0ZSgpO1xuICAgICAgICBpZiAoIXVwZGF0ZWQgJiYgdGhpcy5zdWJzY3JpYmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocy5vblNldChhZCwgYWN0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLnNlbGZVc2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRlTWV0aG9kc0ltcGwucHJvdG90eXBlLCBcImtleXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gTnVtYmVyKGkpOyB9KS5maWx0ZXIoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIE51bWJlci5pc0ludGVnZXIoaSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE9iamVjdCh2YWx1ZSkgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTdGF0ZU1ldGhvZHNJbXBsLnByb3RvdHlwZS5jaGlsZCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlblVzZWQgPSB0aGlzLmNoaWxkcmVuVXNlZCB8fCB7fTtcbiAgICAgICAgdmFyIGNhY2hlZENoaWxkID0gdGhpcy5jaGlsZHJlblVzZWQuaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0aGlzLmNoaWxkcmVuVXNlZFtrZXldO1xuICAgICAgICBpZiAoY2FjaGVkQ2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWVTb3VyY2UgPSB0aGlzLnZhbHVlU291cmNlW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWVTb3VyY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGhpdHRpbmcgYSBtZXRob2Qgb2YgYSBjdXN0b20gdHlwZSwgc2hvdWxkIGJlIG5vLW9wXG4gICAgICAgICAgICB0aHJvdyBuZXcgU3RhdGVJbnZhbGlkVXNhZ2VFcnJvcih0aGlzLnBhdGgsIEVycm9ySWQuR2V0UHJvcGVydHlfRnVuY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW5DcmVhdGVkID0gdGhpcy5jaGlsZHJlbkNyZWF0ZWQgfHwge307XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5DcmVhdGVkW2tleV07XG4gICAgICAgIHZhciByO1xuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLnJlY29uc3RydWN0KHRoaXMucGF0aC5jb25jYXQoa2V5KSwgdmFsdWVTb3VyY2UsIHRoaXMudmFsdWVFZGl0aW9uLCBmYWxzZSk7XG4gICAgICAgICAgICByID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByID0gbmV3IFN0YXRlTWV0aG9kc0ltcGwodGhpcy5zdG9yZSwgdGhpcy5wYXRoLmNvbmNhdChrZXkpLCB2YWx1ZVNvdXJjZSwgdGhpcy52YWx1ZUVkaXRpb24sIHRoaXMub25TZXRVc2VkKTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5DcmVhdGVkW2tleV0gPSByO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZhbHVlVXNlZE5vUHJveHkpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBpcyByZWR1bmRhbnQgd2hlbiBEb3duZ3JhZGVkIHBsdWdpbiBpcyBkZWxldGVkXG4gICAgICAgICAgICByLnZhbHVlVXNlZE5vUHJveHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW5Vc2VkW2tleV0gPSByO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIFN0YXRlTWV0aG9kc0ltcGwucHJvdG90eXBlLnZhbHVlQXJyYXlJbXBsID0gZnVuY3Rpb24gKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gcHJveHlXcmFwKHRoaXMucGF0aCwgY3VycmVudFZhbHVlLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjdXJyZW50VmFsdWU7IH0sIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2xlbmd0aCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXkgaW4gQXJyYXkucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleSA9PT0gU2VsZk1ldGhvZHNJRCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIC8vIGFsbG93IGNsaWVudHMgdG8gYXNzb2NpYXRlIGhpZGRlbiBjYWNoZSB3aXRoIHN0YXRlIHZhbHVlc1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbmRleCA9IE51bWJlcihrZXkpO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGluZGV4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuY2hpbGQoaW5kZXgpLmdldCgpO1xuICAgICAgICB9LCBmdW5jdGlvbiAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgICAgICAvLyBhbGxvdyBjbGllbnRzIHRvIGFzc29jaWF0ZSBoaWRkZW4gY2FjaGUgd2l0aCBzdGF0ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFN0YXRlSW52YWxpZFVzYWdlRXJyb3IoX3RoaXMucGF0aCwgRXJyb3JJZC5TZXRQcm9wZXJ0eV9WYWx1ZSk7XG4gICAgICAgIH0sIHRydWUpO1xuICAgIH07XG4gICAgU3RhdGVNZXRob2RzSW1wbC5wcm90b3R5cGUudmFsdWVPYmplY3RJbXBsID0gZnVuY3Rpb24gKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gcHJveHlXcmFwKHRoaXMucGF0aCwgY3VycmVudFZhbHVlLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjdXJyZW50VmFsdWU7IH0sIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXkgPT09IFNlbGZNZXRob2RzSUQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgICAgICAvLyBhbGxvdyBjbGllbnRzIHRvIGFzc29jaWF0ZSBoaWRkZW4gY2FjaGUgd2l0aCBzdGF0ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuY2hpbGQoa2V5KS5nZXQoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgLy8gYWxsb3cgY2xpZW50cyB0byBhc3NvY2lhdGUgaGlkZGVuIGNhY2hlIHdpdGggc3RhdGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBTdGF0ZUludmFsaWRVc2FnZUVycm9yKF90aGlzLnBhdGgsIEVycm9ySWQuU2V0UHJvcGVydHlfVmFsdWUpO1xuICAgICAgICB9LCB0cnVlKTtcbiAgICB9O1xuICAgIFN0YXRlTWV0aG9kc0ltcGwucHJvdG90eXBlLnNlbGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnNlbGZVc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxmVXNlZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ2V0dGVyID0gZnVuY3Rpb24gKF8sIGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gc2VsZikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAndG9KU09OJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdGF0ZUludmFsaWRVc2FnZUVycm9yKF90aGlzLnBhdGgsIEVycm9ySWQuVG9Kc29uX1N0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXN0ZWRHZXR0ZXIgPSBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBfdGhpcy5nZXQoeyBfX2ludGVybmFsQWxsb3dQcm9taXNlZDogcHJvcCA9PT0gJyQkdHlwZW9mJyB8fCBwcm9wID09PSAnY29uc3RydWN0b3InIH0pO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wIGluIE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFyayBpdCB1c2VkIGVudGlyZWx5LCBzbyBjaGFuZ2VzIHRvIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBpbnZhbGlkYXRlIGFuZCByZXJlbmRlciByZXN1bHRzIGZvciBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBleGFtcGxlLlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjaGVjayBmb3IgT2JqZWN0IHByb3RvdHlwZSBmdW5jdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlbiBmb3IgcHJpbWl0aXZlIHZhbHVlcywgYmVjYXVzZSBwcmltaXRpdmUgdmFsdWVzIHN0aWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbiBoYXZlIG9iamVjdCBtZXRob2RzLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCAvLyBpZiBjdXJyZW50VmFsdWUgaXMgcHJpbWl0aXZlIHR5cGVcbiAgICAgICAgICAgICAgICAoT2JqZWN0KGN1cnJlbnRWYWx1ZSkgIT09IGN1cnJlbnRWYWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgcHJvbWlzZWQsIGl0IHdpbGwgYmUgbm9uZVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgIT09IG5vbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3YXMgYW4gZXJyb3IgY2FzZSwgYnV0IHZhcmlvdXMgdG9vbHMgbGlrZSB3ZWJwYWNrIGJ1bmRsZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHJlYWN0IGRldiB0b29scyBhdHRlbXB0IHRvIGdldCBwcm9wcyBvdXQgb2Ygbm9uLW51bGwgb2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICAvLyBzbyB0aGlzIHdhcyBjaGFuZ2VkIHRvIHJldHVybiBqdXN0IHVuZGVmaW5lZCBmb3IgYW55IHByb3BlcnR5IHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgdGhlcmUgaXMgbm8gd2F5IHRvIGZpeCAzcmQgcGFydHkgdG9vbHMuXG4gICAgICAgICAgICAgICAgICAgIC8vIExvZ2dpbmcgYSB3YXJuaW5nIHRvIGNvbnNvbGUgaXMgYWxzbyBub3QgYW4gb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIGl0IHBvbGx1dGVzIGNvbnNvbGUgZm9yIGxlZ2l0aW1hdGUgYXBwcyBvbiBhcHAgc3RhcnQgYXBwLlxuICAgICAgICAgICAgICAgICAgICAvLyBSZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9hdmtvbnN0L2hvb2tzdGF0ZS9pc3N1ZXMvMTI1XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgPT09ICdsZW5ndGgnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcCBpbiBBcnJheS5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGVbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gTnVtYmVyKHByb3ApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5uZXN0ZWQoaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubmVzdGVkKHByb3AudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdwYXRoJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnBhdGg7XG4gICAgICAgICAgICAgICAgY2FzZSAna2V5cyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5rZXlzO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29ybnVsbCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5vcm51bGw7XG4gICAgICAgICAgICAgICAgY2FzZSAncHJvbWlzZWQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvbWlzZWQ7XG4gICAgICAgICAgICAgICAgY2FzZSAncHJvbWlzZSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9taXNlO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVycm9yO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2dldCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAob3B0cykgeyByZXR1cm4gX3RoaXMuZ2V0KG9wdHMpOyB9O1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocCkgeyByZXR1cm4gX3RoaXMuc2V0KHApOyB9O1xuICAgICAgICAgICAgICAgIGNhc2UgJ21lcmdlJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7IHJldHVybiBfdGhpcy5tZXJnZShwKTsgfTtcbiAgICAgICAgICAgICAgICBjYXNlICduZXN0ZWQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHApIHsgcmV0dXJuIG5lc3RlZEdldHRlcihwKTsgfTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBleHRlbnNpb24gbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgIHZhciBleHQgPSBfdGhpcy5zdG9yZS5leHRlbnNpb247XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHQgJiYga2V5IGluIGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4dFtrZXldKF90aGlzLnNlbGYoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIG5lc3RlZCBjaGlsZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmVzdGVkR2V0dGVyKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VsZlVzZWQgPSBwcm94eVdyYXAodGhpcy5wYXRoLCB0aGlzLnZhbHVlU291cmNlLCBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldCh7IF9faW50ZXJuYWxBbGxvd1Byb21pc2VkOiB0cnVlLCBzdGVhbHRoOiBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc3RlYWx0aCB9KTtcbiAgICAgICAgfSwgZ2V0dGVyLCBmdW5jdGlvbiAoXywga2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN0YXRlSW52YWxpZFVzYWdlRXJyb3IoX3RoaXMucGF0aCwgRXJyb3JJZC5TZXRQcm9wZXJ0eV9TdGF0ZSk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZlVzZWQ7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhdGVNZXRob2RzSW1wbC5wcm90b3R5cGUsIFwicHJvbWlzZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0KHsgX19pbnRlcm5hbEFsbG93UHJvbWlzZWQ6IHRydWUgfSk7IC8vIG1hcmtzIHVzZWRcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuc3RvcmUucHJvbWlzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZU1ldGhvZHNJbXBsLnByb3RvdHlwZSwgXCJwcm9taXNlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdGhpcy5nZXQoeyBfX2ludGVybmFsQWxsb3dQcm9taXNlZDogdHJ1ZSB9KTsgLy8gbWFya3MgdXNlZFxuICAgICAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuc3RvcmUucHJvbWlzZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRoZW4oZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF90aGlzLnNlbGYoKTsgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhdGVNZXRob2RzSW1wbC5wcm90b3R5cGUsIFwiZXJyb3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0KHsgX19pbnRlcm5hbEFsbG93UHJvbWlzZWQ6ICEhdGhpcy5zdG9yZS5wcm9taXNlRXJyb3IgfSk7IC8vIG1hcmtzIHVzZWRcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3JlLnByb21pc2VFcnJvcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZU1ldGhvZHNJbXBsLnByb3RvdHlwZSwgXCJvcm51bGxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGYoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBTdGF0ZU1ldGhvZHNJbXBsO1xufSgpKTtcbmZ1bmN0aW9uIHByb3h5V3JhcChwYXRoLCBcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tYW55XG50YXJnZXRCb290c3RyYXAsIFxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1hbnlcbnRhcmdldEdldHRlciwgXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLWFueVxucHJvcGVydHlHZXR0ZXIsIFxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1hbnlcbnByb3BlcnR5U2V0dGVyLCBpc1ZhbHVlUHJveHkpIHtcbiAgICB2YXIgb25JbnZhbGlkVXNhZ2UgPSBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0YXRlSW52YWxpZFVzYWdlRXJyb3IocGF0aCwgb3ApO1xuICAgIH07XG4gICAgaWYgKE9iamVjdCh0YXJnZXRCb290c3RyYXApICE9PSB0YXJnZXRCb290c3RyYXApIHtcbiAgICAgICAgdGFyZ2V0Qm9vdHN0cmFwID0ge307XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJveHkodGFyZ2V0Qm9vdHN0cmFwLCB7XG4gICAgICAgIGdldFByb3RvdHlwZU9mOiBmdW5jdGlvbiAoX3RhcmdldCkge1xuICAgICAgICAgICAgLy8gc2hvdWxkIHNhdGlzZnkgdGhlIGludmFyaWFudHM6XG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm94eS9oYW5kbGVyL2dldFByb3RvdHlwZU9mI0ludmFyaWFudHNcbiAgICAgICAgICAgIHZhciB0YXJnZXRSZWFsID0gdGFyZ2V0R2V0dGVyKCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0UmVhbCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldFJlYWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXRSZWFsID09PSBub25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgUHJvbWlzZShmdW5jdGlvbiAoKSB7IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0UmVhbCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFByb3RvdHlwZU9mOiBmdW5jdGlvbiAoX3RhcmdldCwgdikge1xuICAgICAgICAgICAgcmV0dXJuIG9uSW52YWxpZFVzYWdlKGlzVmFsdWVQcm94eSA/XG4gICAgICAgICAgICAgICAgRXJyb3JJZC5TZXRQcm90b3R5cGVPZl9TdGF0ZSA6XG4gICAgICAgICAgICAgICAgRXJyb3JJZC5TZXRQcm90b3R5cGVPZl9WYWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24gKF90YXJnZXQpIHtcbiAgICAgICAgICAgIC8vIHNob3VsZCBzYXRpc2Z5IHRoZSBpbnZhcmlhbnRzOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJveHkvaGFuZGxlci9pc0V4dGVuc2libGUjSW52YXJpYW50c1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIHJlcXVpcmVkIHRvIHNhdGlzZnkgdGhlIGludmFyaWFudHMgb2YgdGhlIGdldFByb3RvdHlwZU9mXG4gICAgICAgICAgICAvLyByZXR1cm4gT2JqZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpO1xuICAgICAgICB9LFxuICAgICAgICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gKF90YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBvbkludmFsaWRVc2FnZShpc1ZhbHVlUHJveHkgP1xuICAgICAgICAgICAgICAgIEVycm9ySWQuUHJldmVudEV4dGVuc2lvbnNfU3RhdGUgOlxuICAgICAgICAgICAgICAgIEVycm9ySWQuUHJldmVudEV4dGVuc2lvbnNfVmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIChfdGFyZ2V0LCBwKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0UmVhbCA9IHRhcmdldEdldHRlcigpO1xuICAgICAgICAgICAgaWYgKE9iamVjdCh0YXJnZXRSZWFsKSA9PT0gdGFyZ2V0UmVhbCkge1xuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5fMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0UmVhbCwgcCk7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0UmVhbCkgJiYgcCBpbiBBcnJheS5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbl8xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luXzEgJiYge1xuICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgY29uZmlndXJhYmxlIGFzIG1heSBub3QgZXhpc3Qgb24gcHJveHkgdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogb3JpZ2luXzEuZW51bWVyYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm9wZXJ0eUdldHRlcih0YXJnZXRSZWFsLCBwKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVmFsdWVQcm94eSB8fCB0YXJnZXRSZWFsID09PSBub25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGNvbmZpZ3VyYWJsZSBhcyBkb2VzIG5vdCBleGlzdCBvbiBwcm94eSB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRhcmdldEdldHRlcih7IHN0ZWFsdGg6IHRydWUgfSk7IH0sXG4gICAgICAgICAgICAgICAgICAgIHNldDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwID09PSAncGF0aCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgY29uZmlndXJhYmxlIGFzIGRvZXMgbm90IGV4aXN0IG9uIHByb3h5IHRhcmdldFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGF0aDsgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzOiBmdW5jdGlvbiAoX3RhcmdldCwgcCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0YXJnZXRSZWFsID0gdGFyZ2V0R2V0dGVyKCk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KHRhcmdldFJlYWwpID09PSB0YXJnZXRSZWFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHAgaW4gdGFyZ2V0UmVhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1ZhbHVlUHJveHkgfHwgdGFyZ2V0UmVhbCA9PT0gbm9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwID09PSAndmFsdWUnIHx8IHAgPT09ICdwYXRoJztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBwcm9wZXJ0eUdldHRlcixcbiAgICAgICAgc2V0OiBwcm9wZXJ0eVNldHRlcixcbiAgICAgICAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIChfdGFyZ2V0LCBwKSB7XG4gICAgICAgICAgICByZXR1cm4gb25JbnZhbGlkVXNhZ2UoaXNWYWx1ZVByb3h5ID9cbiAgICAgICAgICAgICAgICBFcnJvcklkLkRlbGV0ZVByb3BlcnR5X1N0YXRlIDpcbiAgICAgICAgICAgICAgICBFcnJvcklkLkRlbGV0ZVByb3BlcnR5X1ZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uIChfdGFyZ2V0LCBwLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gb25JbnZhbGlkVXNhZ2UoaXNWYWx1ZVByb3h5ID9cbiAgICAgICAgICAgICAgICBFcnJvcklkLkRlZmluZVByb3BlcnR5X1N0YXRlIDpcbiAgICAgICAgICAgICAgICBFcnJvcklkLkRlZmluZVByb3BlcnR5X1ZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb3duS2V5czogZnVuY3Rpb24gKF90YXJnZXQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRSZWFsID0gdGFyZ2V0R2V0dGVyKCk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXRSZWFsKSkge1xuICAgICAgICAgICAgICAgIGlmIChfdGFyZ2V0Lmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuIG9iamVjdCB0dXJuZWQgaW50byBhbiBhcnJheSBub3dcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5qZWN0IGxlbmd0aCBwcm9wZXJ0eSBub3cgYXMgaXQgaXMgZGVmaW5lZCBvbiB0aGUgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gZW5hYmxlIGdldE93blByb3BlcnR5RGVzY3JpcHRvciBmb3IgbGVuZ3RoIG5vdCB0aHJvd1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0Qm9vdHN0cmFwLCAnbGVuZ3RoJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDAsIHdyaXRhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoT2JqZWN0KHRhcmdldFJlYWwpID09PSB0YXJnZXRSZWFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldFJlYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVmFsdWVQcm94eSB8fCB0YXJnZXRSZWFsID09PSBub25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFsndmFsdWUnLCAncGF0aCddO1xuICAgICAgICB9LFxuICAgICAgICBhcHBseTogZnVuY3Rpb24gKF90YXJnZXQsIHRoaXNBcmcsIGFyZ0FycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gb25JbnZhbGlkVXNhZ2UoaXNWYWx1ZVByb3h5ID9cbiAgICAgICAgICAgICAgICBFcnJvcklkLkFwcGx5X1N0YXRlIDpcbiAgICAgICAgICAgICAgICBFcnJvcklkLkFwcGx5X1ZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uc3RydWN0OiBmdW5jdGlvbiAoX3RhcmdldCwgYXJnQXJyYXksIG5ld1RhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIG9uSW52YWxpZFVzYWdlKGlzVmFsdWVQcm94eSA/XG4gICAgICAgICAgICAgICAgRXJyb3JJZC5Db25zdHJ1Y3RfU3RhdGUgOlxuICAgICAgICAgICAgICAgIEVycm9ySWQuQ29uc3RydWN0X1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlU3RvcmUoaW5pdGlhbCkge1xuICAgIHZhciBpbml0aWFsVmFsdWUgPSBpbml0aWFsO1xuICAgIGlmICh0eXBlb2YgaW5pdGlhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbml0aWFsVmFsdWUgPSBpbml0aWFsKCk7XG4gICAgfVxuICAgIGlmIChPYmplY3QoaW5pdGlhbFZhbHVlKSA9PT0gaW5pdGlhbFZhbHVlICYmIGluaXRpYWxWYWx1ZVtTZWxmTWV0aG9kc0lEXSkge1xuICAgICAgICB0aHJvdyBuZXcgU3RhdGVJbnZhbGlkVXNhZ2VFcnJvcihSb290UGF0aCwgRXJyb3JJZC5Jbml0U3RhdGVUb1ZhbHVlRnJvbVN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdG9yZShpbml0aWFsVmFsdWUpO1xufVxudmFyIGNvbmZpZ3VyYXRpb24gPSB7XG4gICAgaW50ZXJjZXB0RGVwZW5kZW5jeUxpc3RzTW9kZTogJ2Fsd2F5cycsXG4gICAgaXNEZXZlbG9wbWVudE1vZGU6IHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICAgICAgICB0eXBlb2YgcHJvY2Vzcy5lbnYgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnLFxuICAgIHByb21pc2VEZXRlY3RvcjogZnVuY3Rpb24gKHApIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwKSA9PT0gcDsgfSxcbiAgICBoaWRkZW5JbnRlcmNlcHREZXBlbmRlbmN5TGlzdHNNb2RlRGVidWc6IGZhbHNlXG59O1xuLyoqXG4gKiBDb25maWd1cmVzIEhvb2tzdGF0ZSBiZWhhdmlvciBnbG9iYWxseS4gVGhpcyBpcyBmb3Igc3BlY2lhbCBjYXNlcyBvbmx5LCB3aGVuIGRlZmF1bHRcbiAqIGhldXJpc3RpY3MgZmFpbCB0byB3b3JrIGluIGEgc3BlY2lmaWMgZW52aXJvbm1lbnQuXG4gKlxuICogQHBhcmFtIGNvbmZpZ1xuICovXG5mdW5jdGlvbiBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uZmlndXJhdGlvbiA9IHtcbiAgICAgICAgaW50ZXJjZXB0RGVwZW5kZW5jeUxpc3RzTW9kZTogKF9hID0gY29uZmlnLmludGVyY2VwdERlcGVuZGVuY3lMaXN0c01vZGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbmZpZ3VyYXRpb24uaW50ZXJjZXB0RGVwZW5kZW5jeUxpc3RzTW9kZSxcbiAgICAgICAgaXNEZXZlbG9wbWVudE1vZGU6IChfYiA9IGNvbmZpZy5pc0RldmVsb3BtZW50TW9kZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY29uZmlndXJhdGlvbi5pc0RldmVsb3BtZW50TW9kZSxcbiAgICAgICAgcHJvbWlzZURldGVjdG9yOiAoX2MgPSBjb25maWcucHJvbWlzZURldGVjdG9yKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBjb25maWd1cmF0aW9uLnByb21pc2VEZXRlY3RvcixcbiAgICAgICAgaGlkZGVuSW50ZXJjZXB0RGVwZW5kZW5jeUxpc3RzTW9kZURlYnVnOiBmYWxzZVxuICAgIH07XG4gICAgaW50ZXJjZXB0UmVhY3RIb29rcygpOyAvLyBub3QgcmVhbGx5IHJlcXVpcmVkLCBidXQgZm9yIHNhZmV0eVxuICAgIGlmIChjb25maWd1cmF0aW9uLmludGVyY2VwdERlcGVuZGVuY3lMaXN0c01vZGUgPT09ICduZXZlcicpIHtcbiAgICAgICAgY29uZmlndXJhdGlvbi5oaWRkZW5JbnRlcmNlcHREZXBlbmRlbmN5TGlzdHNNb2RlRGVidWcgPSBmYWxzZTtcbiAgICAgICAgUmVhY3RbJ3VzZUVmZmVjdCddID0gUmVhY3RbJ3VzZUVmZmVjdCddICYmIHVzZUVmZmVjdE9yaWdpbjtcbiAgICAgICAgUmVhY3RbJ3VzZUxheW91dEVmZmVjdCddID0gUmVhY3RbJ3VzZUxheW91dEVmZmVjdCddICYmIHVzZUxheW91dEVmZmVjdE9yaWdpbjtcbiAgICAgICAgUmVhY3RbJ3VzZUluc2VydGlvbkVmZmVjdCddID0gUmVhY3RbJ3VzZUluc2VydGlvbkVmZmVjdCddICYmIHVzZUluc2VydGlvbkVmZmVjdE9yaWdpbjtcbiAgICAgICAgUmVhY3RbJ3VzZUltcGVyYXRpdmVIYW5kbGUnXSA9IFJlYWN0Wyd1c2VJbXBlcmF0aXZlSGFuZGxlJ10gJiYgdXNlSW1wZXJhdGl2ZUhhbmRsZU9yaWdpbjtcbiAgICAgICAgUmVhY3RbJ3VzZU1lbW8nXSA9IFJlYWN0Wyd1c2VNZW1vJ10gJiYgdXNlTWVtb09yaWdpbjtcbiAgICAgICAgUmVhY3RbJ3VzZUNhbGxiYWNrJ10gPSBSZWFjdFsndXNlQ2FsbGJhY2snXSAmJiB1c2VDYWxsYmFja09yaWdpbjtcbiAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBkb2VzIG5vdCBtYWtlIGFuIGVmZmVjdCBhcyBtZW1vIGNhbGxzIGhhcHBlbiBvbiBtb2R1bGUgbG9hZFxuICAgICAgICAvLyBzbyBpdCBpcyBhbHdheXMgc2V0IHRvIG1lbW9JbnRlcmNlcHRcbiAgICAgICAgUmVhY3RbJ21lbW8nXSA9IFJlYWN0WydtZW1vJ10gJiYgbWVtb09yaWdpbjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGRvIG5vdCBpbnRlcmNlcHQgaWYgYSBob29rIGlzIG5vdCBkZWZpbmVkIGluIFJlYWN0XG4gICAgICAgIC8vIG90aGVyd2lzZSwgaXQgd2lsbCBlbmFibGUgM3JkIHBhcnR5IGxpYnMgdGhpbmtpbmcgdGhlIHJlYWN0IHJ1bnMgYXQgdmVyc2lvbiAxOFxuICAgICAgICBSZWFjdFsndXNlRWZmZWN0J10gPSBSZWFjdFsndXNlRWZmZWN0J10gJiYgdXNlRWZmZWN0SW50ZXJjZXB0O1xuICAgICAgICBSZWFjdFsndXNlTGF5b3V0RWZmZWN0J10gPSBSZWFjdFsndXNlTGF5b3V0RWZmZWN0J10gJiYgdXNlTGF5b3V0RWZmZWN0SW50ZXJjZXB0O1xuICAgICAgICBSZWFjdFsndXNlSW5zZXJ0aW9uRWZmZWN0J10gPSBSZWFjdFsndXNlTGF5b3V0RWZmZWN0J10gJiYgdXNlSW5zZXJ0aW9uRWZmZWN0SW50ZXJjZXB0O1xuICAgICAgICBSZWFjdFsndXNlSW1wZXJhdGl2ZUhhbmRsZSddID0gUmVhY3RbJ3VzZUltcGVyYXRpdmVIYW5kbGUnXSAmJiB1c2VJbXBlcmF0aXZlSGFuZGxlSW50ZXJjZXB0O1xuICAgICAgICBSZWFjdFsndXNlTWVtbyddID0gUmVhY3RbJ3VzZU1lbW8nXSAmJiB1c2VNZW1vSW50ZXJjZXB0O1xuICAgICAgICBSZWFjdFsndXNlQ2FsbGJhY2snXSA9IFJlYWN0Wyd1c2VDYWxsYmFjayddICYmIHVzZUNhbGxiYWNrSW50ZXJjZXB0O1xuICAgICAgICAvLyB0aGUgZm9sbG93aW5nIGRvZXMgbm90IG1ha2UgYW4gZWZmZWN0IGFzIG1lbW8gY2FsbHMgaGFwcGVuIG9uIG1vZHVsZSBsb2FkXG4gICAgICAgIC8vIHNvIGl0IGlzIGFsd2F5cyBzZXQgdG8gbWVtb0ludGVyY2VwdFxuICAgICAgICBSZWFjdFsnbWVtbyddID0gUmVhY3RbJ21lbW8nXSAmJiBtZW1vSW50ZXJjZXB0O1xuICAgICAgICBpZiAoY29uZmlndXJhdGlvbi5pbnRlcmNlcHREZXBlbmRlbmN5TGlzdHNNb2RlID09PSAnZGV2ZWxvcG1lbnQnXG4gICAgICAgICAgICAmJiBjb25maWd1cmF0aW9uLmlzRGV2ZWxvcG1lbnRNb2RlKSB7XG4gICAgICAgICAgICBjb25maWd1cmF0aW9uLmhpZGRlbkludGVyY2VwdERlcGVuZGVuY3lMaXN0c01vZGVEZWJ1ZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiByZWNvbm5lY3REZXBlbmRlbmNpZXMoZGVwcywgZnJvbUludGVyY2VwdCkge1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBkZXBzIHx8IFtdOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgaSA9IF9hW19pXTtcbiAgICAgICAgaWYgKGkgPT09IE9iamVjdChpKSkge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gaVtzZWxmXTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChmcm9tSW50ZXJjZXB0ICYmIGNvbmZpZ3VyYXRpb24uaGlkZGVuSW50ZXJjZXB0RGVwZW5kZW5jeUxpc3RzTW9kZURlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdGF0ZUludmFsaWRVc2FnZUVycm9yKHN0YXRlLnBhdGgsIEVycm9ySWQuU3RhdGVVc2VkSW5EZXBlbmRlbmN5TGlzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLnJlY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXBzO1xufVxudmFyIHVzZUVmZmVjdE9yaWdpbjtcbmZ1bmN0aW9uIHVzZUhvb2tzdGF0ZUVmZmVjdChlZmZlY3QsIGRlcHMpIHtcbiAgICByZWNvbm5lY3REZXBlbmRlbmNpZXMoZGVwcyk7XG4gICAgcmV0dXJuIHVzZUVmZmVjdE9yaWdpbihlZmZlY3QsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlRWZmZWN0SW50ZXJjZXB0KGVmZmVjdCwgZGVwcykge1xuICAgIHJlY29ubmVjdERlcGVuZGVuY2llcyhkZXBzLCB0cnVlKTtcbiAgICByZXR1cm4gdXNlRWZmZWN0T3JpZ2luKGVmZmVjdCwgZGVwcyk7XG59XG52YXIgdXNlTGF5b3V0RWZmZWN0T3JpZ2luO1xuZnVuY3Rpb24gdXNlSG9va3N0YXRlTGF5b3V0RWZmZWN0KGVmZmVjdCwgZGVwcykge1xuICAgIHJlY29ubmVjdERlcGVuZGVuY2llcyhkZXBzKTtcbiAgICByZXR1cm4gdXNlTGF5b3V0RWZmZWN0T3JpZ2luKGVmZmVjdCwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3RJbnRlcmNlcHQoZWZmZWN0LCBkZXBzKSB7XG4gICAgcmVjb25uZWN0RGVwZW5kZW5jaWVzKGRlcHMsIHRydWUpO1xuICAgIHJldHVybiB1c2VMYXlvdXRFZmZlY3RPcmlnaW4oZWZmZWN0LCBkZXBzKTtcbn1cbnZhciB1c2VJbnNlcnRpb25FZmZlY3RPcmlnaW47XG5mdW5jdGlvbiB1c2VIb29rc3RhdGVJbnNlcnRpb25FZmZlY3QoZWZmZWN0LCBkZXBzKSB7XG4gICAgcmVjb25uZWN0RGVwZW5kZW5jaWVzKGRlcHMpO1xuICAgIHJldHVybiB1c2VJbnNlcnRpb25FZmZlY3RPcmlnaW4oZWZmZWN0LCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUluc2VydGlvbkVmZmVjdEludGVyY2VwdChlZmZlY3QsIGRlcHMpIHtcbiAgICByZWNvbm5lY3REZXBlbmRlbmNpZXMoZGVwcywgdHJ1ZSk7XG4gICAgcmV0dXJuIHVzZUluc2VydGlvbkVmZmVjdE9yaWdpbihlZmZlY3QsIGRlcHMpO1xufVxudmFyIHVzZUltcGVyYXRpdmVIYW5kbGVPcmlnaW47XG5mdW5jdGlvbiB1c2VIb29rc3RhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgaW5pdCwgZGVwcykge1xuICAgIHJlY29ubmVjdERlcGVuZGVuY2llcyhkZXBzKTtcbiAgICByZXR1cm4gdXNlSW1wZXJhdGl2ZUhhbmRsZU9yaWdpbihyZWYsIGluaXQsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZUhhbmRsZUludGVyY2VwdChyZWYsIGluaXQsIGRlcHMpIHtcbiAgICByZWNvbm5lY3REZXBlbmRlbmNpZXMoZGVwcywgdHJ1ZSk7XG4gICAgcmV0dXJuIHVzZUltcGVyYXRpdmVIYW5kbGVPcmlnaW4ocmVmLCBpbml0LCBkZXBzKTtcbn1cbnZhciB1c2VNZW1vT3JpZ2luO1xuZnVuY3Rpb24gdXNlSG9va3N0YXRlTWVtbyhmYWN0b3J5LCBkZXBzKSB7XG4gICAgcmVjb25uZWN0RGVwZW5kZW5jaWVzKGRlcHMpO1xuICAgIHJldHVybiB1c2VNZW1vT3JpZ2luKGZhY3RvcnksIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTWVtb0ludGVyY2VwdChmYWN0b3J5LCBkZXBzKSB7XG4gICAgcmVjb25uZWN0RGVwZW5kZW5jaWVzKGRlcHMsIHRydWUpO1xuICAgIHJldHVybiB1c2VNZW1vT3JpZ2luKGZhY3RvcnksIGRlcHMpO1xufVxudmFyIHVzZUNhbGxiYWNrT3JpZ2luO1xuZnVuY3Rpb24gdXNlSG9va3N0YXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgICByZWNvbm5lY3REZXBlbmRlbmNpZXMoZGVwcyk7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrT3JpZ2luKGNhbGxiYWNrLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrSW50ZXJjZXB0KGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgcmVjb25uZWN0RGVwZW5kZW5jaWVzKGRlcHMsIHRydWUpO1xuICAgIHJldHVybiB1c2VDYWxsYmFja09yaWdpbihjYWxsYmFjaywgZGVwcyk7XG59XG52YXIgbWVtb09yaWdpbjtcbmZ1bmN0aW9uIGhvb2tzdGF0ZU1lbW8oQ29tcG9uZW50LCBwcm9wc0FyZUVxdWFsKSB7XG4gICAgcmV0dXJuIG1lbW9PcmlnaW4oQ29tcG9uZW50LCBmdW5jdGlvbiAocHJldlByb3BzLCBuZXh0UHJvcHMpIHtcbiAgICAgICAgcmVjb25uZWN0RGVwZW5kZW5jaWVzKE9iamVjdC5rZXlzKG5leHRQcm9wcykubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBuZXh0UHJvcHNbaV07IH0pKTtcbiAgICAgICAgcmV0dXJuIChwcm9wc0FyZUVxdWFsIHx8IHNoYWxsb3dFcXVhbCkocHJldlByb3BzLCBuZXh0UHJvcHMpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbWVtb0ludGVyY2VwdChDb21wb25lbnQsIHByb3BzQXJlRXF1YWwpIHtcbiAgICByZXR1cm4gbWVtb09yaWdpbihDb21wb25lbnQsIGZ1bmN0aW9uIChwcmV2UHJvcHMsIG5leHRQcm9wcykge1xuICAgICAgICByZWNvbm5lY3REZXBlbmRlbmNpZXMoT2JqZWN0LmtleXMobmV4dFByb3BzKS5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIG5leHRQcm9wc1tpXTsgfSksIHRydWUpO1xuICAgICAgICByZXR1cm4gKHByb3BzQXJlRXF1YWwgfHwgc2hhbGxvd0VxdWFsKShwcmV2UHJvcHMsIG5leHRQcm9wcyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpbnRlcmNlcHRSZWFjdEhvb2tzKCkge1xuICAgIGlmICghdXNlRWZmZWN0T3JpZ2luICYmIFJlYWN0Wyd1c2VFZmZlY3QnXSkge1xuICAgICAgICB1c2VFZmZlY3RPcmlnaW4gPSBSZWFjdFsndXNlRWZmZWN0J107XG4gICAgICAgIFJlYWN0Wyd1c2VFZmZlY3QnXSA9IHVzZUVmZmVjdEludGVyY2VwdDtcbiAgICB9XG4gICAgaWYgKCF1c2VMYXlvdXRFZmZlY3RPcmlnaW4gJiYgUmVhY3RbJ3VzZUxheW91dEVmZmVjdCddKSB7XG4gICAgICAgIHVzZUxheW91dEVmZmVjdE9yaWdpbiA9IFJlYWN0Wyd1c2VMYXlvdXRFZmZlY3QnXTtcbiAgICAgICAgUmVhY3RbJ3VzZUxheW91dEVmZmVjdCddID0gdXNlTGF5b3V0RWZmZWN0SW50ZXJjZXB0O1xuICAgIH1cbiAgICBpZiAoIXVzZUluc2VydGlvbkVmZmVjdE9yaWdpbiAmJiBSZWFjdFsndXNlSW5zZXJ0aW9uRWZmZWN0J10pIHtcbiAgICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0T3JpZ2luID0gUmVhY3RbJ3VzZUluc2VydGlvbkVmZmVjdCddO1xuICAgICAgICBSZWFjdFsndXNlSW5zZXJ0aW9uRWZmZWN0J10gPSB1c2VJbnNlcnRpb25FZmZlY3RJbnRlcmNlcHQ7XG4gICAgfVxuICAgIGlmICghdXNlSW1wZXJhdGl2ZUhhbmRsZU9yaWdpbiAmJiBSZWFjdFsndXNlSW1wZXJhdGl2ZUhhbmRsZSddKSB7XG4gICAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGVPcmlnaW4gPSBSZWFjdFsndXNlSW1wZXJhdGl2ZUhhbmRsZSddO1xuICAgICAgICBSZWFjdFsndXNlSW1wZXJhdGl2ZUhhbmRsZSddID0gdXNlSW1wZXJhdGl2ZUhhbmRsZUludGVyY2VwdDtcbiAgICB9XG4gICAgaWYgKCF1c2VNZW1vT3JpZ2luICYmIFJlYWN0Wyd1c2VNZW1vJ10pIHtcbiAgICAgICAgdXNlTWVtb09yaWdpbiA9IFJlYWN0Wyd1c2VNZW1vJ107XG4gICAgICAgIFJlYWN0Wyd1c2VNZW1vJ10gPSB1c2VNZW1vSW50ZXJjZXB0O1xuICAgIH1cbiAgICBpZiAoIXVzZUNhbGxiYWNrT3JpZ2luICYmIFJlYWN0Wyd1c2VDYWxsYmFjayddKSB7XG4gICAgICAgIHVzZUNhbGxiYWNrT3JpZ2luID0gUmVhY3RbJ3VzZUNhbGxiYWNrJ107XG4gICAgICAgIFJlYWN0Wyd1c2VDYWxsYmFjayddID0gdXNlQ2FsbGJhY2tJbnRlcmNlcHQ7XG4gICAgfVxuICAgIGlmICghbWVtb09yaWdpbiAmJiBSZWFjdFsnbWVtbyddKSB7XG4gICAgICAgIG1lbW9PcmlnaW4gPSBSZWFjdFsnbWVtbyddO1xuICAgICAgICBSZWFjdFsnbWVtbyddID0gbWVtb0ludGVyY2VwdDtcbiAgICB9XG59XG5pbnRlcmNlcHRSZWFjdEhvb2tzKCk7IC8vIFRPRE8gZGVmZXIgaW52b2tpbmcgaXQgdW50aWwgc3RhdGUgaXMgY3JlYXRlZCwgc28gdGhlIGNvbmZpZ3VyZSBoYWQgYSBjaGFuY2UgdG8gc2V0IGl0IHVwIGZpcnN0XG4vLyBEbyBub3QgdHJ5IHRvIHVzZSB1c2VMYXlvdXRFZmZlY3QgaWYgRE9NIG5vdCBhdmFpbGFibGUgKFNTUilcbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3RPcmlnaW4gOiB1c2VFZmZlY3RPcmlnaW47XG5cbmV4cG9ydCB7IFN0YXRlRnJhZ21lbnQsIF9fc3RhdGUsIGNvbmZpZ3VyZSwgZGVzdHJveSwgZXh0ZW5kLCBob29rc3RhdGUsIGhvb2tzdGF0ZU1lbW8sIGlzSG9va3N0YXRlLCBpc0hvb2tzdGF0ZVZhbHVlLCBub25lLCBzdXNwZW5kLCB1c2VIb29rc3RhdGUsIHVzZUhvb2tzdGF0ZUNhbGxiYWNrLCB1c2VIb29rc3RhdGVFZmZlY3QsIHVzZUhvb2tzdGF0ZUltcGVyYXRpdmVIYW5kbGUsIHVzZUhvb2tzdGF0ZUluc2VydGlvbkVmZmVjdCwgdXNlSG9va3N0YXRlTGF5b3V0RWZmZWN0LCB1c2VIb29rc3RhdGVNZW1vIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImV4dGVuZFN0YXRpY3MiLCJkIiwiYiIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQXJyYXkiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX19leHRlbmRzIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiX18iLCJjb25zdHJ1Y3RvciIsImNyZWF0ZSIsIl9fYXNzaWduIiwiYXNzaWduIiwidCIsInMiLCJpIiwibiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFwcGx5IiwiaXMiLCJ4IiwieSIsInNoYWxsb3dFcXVhbCIsIm9iakEiLCJvYmpCIiwia2V5c0EiLCJrZXlzIiwia2V5c0IiLCJub25lIiwiU3ltYm9sIiwiX19zdGF0ZSIsImhvb2tzdGF0ZSIsImluaXRpYWwiLCJleHRlbnNpb24iLCJzdG9yZSIsImNyZWF0ZVN0b3JlIiwiYWN0aXZhdGUiLCJtZXRob2RzIiwidG9NZXRob2RzIiwic2VsZiIsImRlc3Ryb3kiLCJzdGF0ZSIsImRlYWN0aXZhdGUiLCJpc0hvb2tzdGF0ZSIsInYiLCJpc0hvb2tzdGF0ZVZhbHVlIiwiU2VsZk1ldGhvZHNJRCIsImV4dGVuZCIsImUxIiwiZTIiLCJlMyIsImU0IiwiZTUiLCJleHRlbmRlZCIsImV4dGVuc2lvbnMiLCJleHRzIiwibWFwIiwib25Jbml0Q2JzIiwib25Jbml0IiwiZmlsdGVyIiwib25QcmVtZXJnZUNicyIsIm9uUHJlbWVyZ2UiLCJvblByZXNldENicyIsIm9uUHJlc2V0Iiwib25TZXRDYnMiLCJvblNldCIsIm9uRGVzdHJveUNicyIsIm9uRGVzdHJveSIsInJlc3VsdCIsIm9uQ3JlYXRlIiwiaW5zdGFuY2VGYWN0b3J5IiwiY29tYmluZWRNZXRob2RzIiwiX2kiLCJleHRzXzEiLCJleHQiLCJleHRNZXRob2RzIiwiZSIsIm9uSW5pdENic18xIiwiY2IiLCJyIiwib25QcmVtZXJnZUNic18xIiwib25QcmVzZXRDYnNfMSIsIm9uU2V0Q2JzXzEiLCJvbkRlc3Ryb3lDYnNfMSIsInVzZUhvb2tzdGF0ZSIsInNvdXJjZSIsInBhcmVudE1ldGhvZHMiLCJ1bmRlZmluZWQiLCJpc01vdW50ZWQiLCJpbml0aWFsaXplciIsIm9uU2V0VXNlZENhbGxiYWNrIiwic2V0VmFsdWVfMSIsInZhbHVlXzEiLCJTdGF0ZU1ldGhvZHNJbXBsIiwicGF0aCIsImdldCIsImVkaXRpb24iLCJfYSIsInVzZVN0YXRlIiwib25Vbm1vdW50IiwidW5zdWJzY3JpYmUiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJyZWNvbnN0cnVjdCIsInN1YnNjcmliZSIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJvbk1vdW50IiwidmFsdWVfMiIsInNldFZhbHVlXzIiLCJSb290UGF0aCIsIl9iIiwiaW5kIiwibmVzdGVkIiwidmFsdWVfMyIsInNldFZhbHVlXzMiLCJfYyIsIlN0YXRlRnJhZ21lbnQiLCJwcm9wcyIsInNjb3BlZCIsInN1c3BlbmQiLCJjaGlsZHJlbiIsInByb21pc2UiLCJjcmVhdGVFbGVtZW50IiwibGF6eSIsIkVycm9ySWQiLCJTdGF0ZUludmFsaWRVc2FnZUVycm9yIiwiX3N1cGVyIiwiaWQiLCJkZXRhaWxzIiwiY29uY2F0Iiwiam9pbiIsIkVycm9yIiwiU3RvcmUiLCJfdmFsdWUiLCJfdGhpcyIsIl9zdWJzY3JpYmVycyIsIlNldCIsImNvbmZpZ3VyYXRpb24iLCJwcm9taXNlRGV0ZWN0b3IiLCJzZXRQcm9taXNlZCIsIm9uU2V0VXNlZFN0b3JlU3RhdGVNZXRob2RzIiwiX3N0YXRlTWV0aG9kcyIsIklzVW5tb3VudGVkIiwiX3Byb21pc2VFcnJvciIsIl9wcm9taXNlUmVzb2x2ZXIiLCJfcHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsInVwZGF0ZSIsInNldCIsImNhdGNoIiwiZXJyIiwiYWQiLCJleHRlbnNpb25GYWN0b3J5IiwiX2QiLCJfZXh0ZW5zaW9uIiwiX2V4dGVuc2lvbk1ldGhvZHMiLCJjb25maWd1cmFibGUiLCJmb3JFYWNoIiwidmFsdWUiLCJTZXRTdGF0ZVdoZW5Qcm9taXNlZCIsInByZXZWYWx1ZSIsImFmdGVyU2V0IiwicmVzb2x2ZXIiLCJTZXRTdGF0ZU5lc3RlZFRvUHJvbWlzZWQiLCJ0YXJnZXQiLCJpc0FycmF5Iiwic3BsaWNlIiwic2xpY2UiLCJhY3Rpb25zIiwicHJlc2V0IiwicHJlbWVyZ2UiLCJ2YWx1ZXMiLCJmaW5kSW5kZXgiLCJrZXkiLCJhIiwibCIsImFkZCIsImRlbGV0ZSIsInRvSlNPTiIsIlRvSnNvbl9WYWx1ZSIsIlVudXNlZFZhbHVlIiwidmFsdWVTb3VyY2UiLCJ2YWx1ZUVkaXRpb24iLCJvblNldFVzZWQiLCJ2YWx1ZVVzZWQiLCJyZXNldCIsInNlbGZVc2VkIiwiY2hpbGRyZW5DcmVhdGVkIiwiY2hpbGRyZW5Vc2VkUHJldmlvdXMiLCJ2YWx1ZVVzZWROb1Byb3h5UHJldmlvdXMiLCJ2YWx1ZVVzZWROb1Byb3h5IiwiY2hpbGRyZW5Vc2VkIiwicmVjb25uZWN0IiwiX19pbnRlcm5hbEFsbG93UHJvbWlzZWQiLCJub3Byb3h5IiwiZ2V0VW50cmFja2VkIiwicHJvbWlzZUVycm9yIiwiR2V0U3RhdGVXaGVuUHJvbWlzZWQiLCJvcHRpb25zIiwic3RlYWx0aCIsInZhbHVlQXJyYXlJbXBsIiwibmFtZSIsInZhbHVlT2JqZWN0SW1wbCIsInNldFVudHJhY2tlZFY0IiwibmV3VmFsdWUiLCJTZXRTdGF0ZVRvVmFsdWVGcm9tU3RhdGUiLCJtZXJnZVVudHJhY2tlZCIsInNvdXJjZVZhbHVlIiwibWVyZ2VVbnRyYWNrZWRWNCIsImN1cnJlbnRWYWx1ZSIsImFkXzEiLCJwdXNoIiwiYWRfMiIsImRlbGV0ZWRJbmRleGVzXzEiLCJOdW1iZXIiLCJzb3J0IiwiaW5kZXgiLCJuZXdQcm9wVmFsdWUiLCJyZXZlcnNlIiwiYWRfMyIsIm1lcmdlIiwiY2hpbGQiLCJyZXJlbmRlciIsInBhdGhzIiwicGF0aHNfMSIsInN1YnNjcmliZXJzIiwiaXNBZmZlY3RlZCIsIm5leHRDaGlsZEtleSIsImluY2x1ZGVzIiwiZmlyc3REZWxldGVkSW5kZXgiLCJmaW5kIiwiY2hpbGRLZXkiLCJuZXh0Q2hpbGQiLCJ1cGRhdGVkIiwiaXNJbnRlZ2VyIiwiY2FjaGVkQ2hpbGQiLCJHZXRQcm9wZXJ0eV9GdW5jdGlvbiIsInByb3h5V3JhcCIsIlNldFByb3BlcnR5X1ZhbHVlIiwiZ2V0dGVyIiwiXyIsIlRvSnNvbl9TdGF0ZSIsIm5lc3RlZEdldHRlciIsInByb3AiLCJ0b1N0cmluZyIsIm9ybnVsbCIsInByb21pc2VkIiwiZXJyb3IiLCJvcHRzIiwiU2V0UHJvcGVydHlfU3RhdGUiLCJ0YXJnZXRCb290c3RyYXAiLCJ0YXJnZXRHZXR0ZXIiLCJwcm9wZXJ0eUdldHRlciIsInByb3BlcnR5U2V0dGVyIiwiaXNWYWx1ZVByb3h5Iiwib25JbnZhbGlkVXNhZ2UiLCJvcCIsIlByb3h5IiwiZ2V0UHJvdG90eXBlT2YiLCJfdGFyZ2V0IiwidGFyZ2V0UmVhbCIsIlNldFByb3RvdHlwZU9mX1N0YXRlIiwiU2V0UHJvdG90eXBlT2ZfVmFsdWUiLCJpc0V4dGVuc2libGUiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsIlByZXZlbnRFeHRlbnNpb25zX1N0YXRlIiwiUHJldmVudEV4dGVuc2lvbnNfVmFsdWUiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJvcmlnaW5fMSIsImhhcyIsImRlbGV0ZVByb3BlcnR5IiwiRGVsZXRlUHJvcGVydHlfU3RhdGUiLCJEZWxldGVQcm9wZXJ0eV9WYWx1ZSIsImF0dHJpYnV0ZXMiLCJEZWZpbmVQcm9wZXJ0eV9TdGF0ZSIsIkRlZmluZVByb3BlcnR5X1ZhbHVlIiwib3duS2V5cyIsIndyaXRhYmxlIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInRoaXNBcmciLCJhcmdBcnJheSIsIkFwcGx5X1N0YXRlIiwiQXBwbHlfVmFsdWUiLCJjb25zdHJ1Y3QiLCJuZXdUYXJnZXQiLCJDb25zdHJ1Y3RfU3RhdGUiLCJDb25zdHJ1Y3RfVmFsdWUiLCJpbml0aWFsVmFsdWUiLCJJbml0U3RhdGVUb1ZhbHVlRnJvbVN0YXRlIiwiaW50ZXJjZXB0RGVwZW5kZW5jeUxpc3RzTW9kZSIsImlzRGV2ZWxvcG1lbnRNb2RlIiwicHJvY2VzcyIsImVudiIsImhpZGRlbkludGVyY2VwdERlcGVuZGVuY3lMaXN0c01vZGVEZWJ1ZyIsImNvbmZpZ3VyZSIsImNvbmZpZyIsImludGVyY2VwdFJlYWN0SG9va3MiLCJ1c2VFZmZlY3RPcmlnaW4iLCJ1c2VMYXlvdXRFZmZlY3RPcmlnaW4iLCJ1c2VJbnNlcnRpb25FZmZlY3RPcmlnaW4iLCJ1c2VJbXBlcmF0aXZlSGFuZGxlT3JpZ2luIiwidXNlTWVtb09yaWdpbiIsInVzZUNhbGxiYWNrT3JpZ2luIiwibWVtb09yaWdpbiIsInVzZUVmZmVjdEludGVyY2VwdCIsInVzZUxheW91dEVmZmVjdEludGVyY2VwdCIsInVzZUluc2VydGlvbkVmZmVjdEludGVyY2VwdCIsInVzZUltcGVyYXRpdmVIYW5kbGVJbnRlcmNlcHQiLCJ1c2VNZW1vSW50ZXJjZXB0IiwidXNlQ2FsbGJhY2tJbnRlcmNlcHQiLCJtZW1vSW50ZXJjZXB0IiwicmVjb25uZWN0RGVwZW5kZW5jaWVzIiwiZGVwcyIsImZyb21JbnRlcmNlcHQiLCJTdGF0ZVVzZWRJbkRlcGVuZGVuY3lMaXN0IiwidXNlSG9va3N0YXRlRWZmZWN0IiwiZWZmZWN0IiwidXNlSG9va3N0YXRlTGF5b3V0RWZmZWN0IiwidXNlSG9va3N0YXRlSW5zZXJ0aW9uRWZmZWN0IiwidXNlSG9va3N0YXRlSW1wZXJhdGl2ZUhhbmRsZSIsInJlZiIsImluaXQiLCJ1c2VIb29rc3RhdGVNZW1vIiwiZmFjdG9yeSIsInVzZUhvb2tzdGF0ZUNhbGxiYWNrIiwiY2FsbGJhY2siLCJob29rc3RhdGVNZW1vIiwiQ29tcG9uZW50IiwicHJvcHNBcmVFcXVhbCIsInByZXZQcm9wcyIsIm5leHRQcm9wcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@hookstate/core/dist/index.es.js\n");

/***/ })

};
;